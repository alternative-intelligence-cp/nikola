# PHASE 0: CRITICAL REQUIREMENTS

## EXECUTIVE SUMMARY

**Date:** December 7, 2025  
**Status:** MANDATORY - NO CODE UNTIL COMPLETE  
**Version:** v0.0.4

This section documents critical engineering requirements that **MUST** be implemented before any feature development begins. These are not optimizations—they are functional requirements to prevent system failure.

### Critical Requirements

1. **Numerical Stability:** Split-operator symplectic integration required for energy conservation
2. **Memory Efficiency:** Structure-of-Arrays layout required for cache optimization
3. **Precision Preservation:** Kahan compensated summation required for Laplacian accuracy
4. **Collision-Free Hashing:** 128-bit Morton codes required for high-resolution 9D grids

### Implementation Mandate

**NO DEVIATION:** All Phase 0 fixes are mandatory architectural requirements. The system CANNOT function correctly without these implementations.

**Timeline:** 17 days (3.5 weeks)  
**Gate:** All P0 and P1 items must pass validation before Phase 1 begins.

---

## 1. STRUCTURE-OF-ARRAYS (SoA) MEMORY LAYOUT

### Problem Statement

The initial specification used Array-of-Structures (AoS) layout:

```cpp
// ❌ FORBIDDEN: AoS layout causes cache thrashing
struct TorusNode {
    std::complex<double> psi;           // 16 bytes
    std::array<double, 45> metric;      // 360 bytes
    std::array<double, 9> christoffel;  // 72 bytes
    // Total: 448 bytes per node
};
```

**Issue:** Computing the Laplacian requires accessing `psi` from 18 neighbors. With AoS, each access pulls 448 bytes into cache but uses only 16 bytes (3.6% efficiency). This causes:
- Cache thrashing (TLB misses destroy performance)
- Memory bandwidth saturation (fetching 90% unused data)
- Poor vectorization (SIMD can't load contiguous psi values)

### Solution: Structure-of-Arrays (SoA)

```cpp
// ✅ MANDATORY: SoA layout for cache efficiency
struct TorusBlock {
    static constexpr int BLOCK_SIZE = 19683;  // 3^9 voxels per block
    
    // Aligned for AVX-512 (64-byte cache lines)
    alignas(64) std::array<float, BLOCK_SIZE> psi_real;
    alignas(64) std::array<float, BLOCK_SIZE> psi_imag;
    alignas(64) std::array<float, BLOCK_SIZE> psi_vel_real;
    alignas(64) std::array<float, BLOCK_SIZE> psi_vel_imag;
    
    // Metric tensor: 45 components × 19683 voxels
    alignas(64) std::array<std::array<float, BLOCK_SIZE>, 45> metric_tensor;
    
    // Christoffel symbols: 9 × 9 × 9 = 729 components (sparse)
    alignas(64) std::array<std::array<float, BLOCK_SIZE>, 729> christoffel;
};

// Proxy accessor class (maintains API compatibility)
class TorusNodeProxy {
    TorusBlock* block;
    size_t index;
    
public:
    std::complex<double> psi() const {
        return {block->psi_real[index], block->psi_imag[index]};
    }
    
    void set_psi(std::complex<double> val) {
        block->psi_real[index] = val.real();
        block->psi_imag[index] = val.imag();
    }
    
    // ... metric accessors ...
};
```

### Implementation Requirements

1. **Refactor all grid code** to use `TorusBlock` arrays instead of `TorusNode` arrays
2. **CUDA kernels** must use coalesced memory access patterns (threads access contiguous indices)
3. **Cache alignment:** All arrays must be 64-byte aligned (`alignas(64)`)
4. **Block size:** Must be power of 3^9 for efficient torus indexing

### Performance Impact

- **Memory bandwidth:** 3.6% → 100% efficiency (28x improvement)
- **Cache hit rate:** ~10% → ~95% (9.5x improvement)
- **Overall speedup:** ~10x for physics kernel

**Priority:** P0 (Critical)  
**Timeline:** 2 days  
**Validation:** Physics kernel must achieve <1ms per step on sparse 27³ grid

### 1.1 9D Dimensional Semantics

Strict type enforcement for dimensional mapping:

| Dimension | Symbol | Role | Data Type | Physics Interpretation |
|-----------|--------|------|-----------|------------------------|
| 1 | $r$ | Resonance | float [0.0, 1.0] | Damping coefficient $\gamma$. High $r$ = Low Damping (Long-term memory) |
| 2 | $s$ | State | float [0.0, 2.0] | Refractive Index $\eta$. Defines local speed of light $c$ |
| 3 | $t$ | Time | float (cyclic) | Temporal phase (modulo $2\pi$) |
| 4-6 | $u,v,w$ | Quantum | float [0.0, 1.0] | Quantum state subspace dimensions |
| 7-9 | $x,y,z$ | Spatial | float [0.0, 1.0] | Physical 3D embedding coordinates |

**Constraint Enforcement:** All coordinate access must validate ranges. Out-of-range values indicate either programming errors or physics violations requiring immediate halt.

---

## 2. SPLIT-OPERATOR SYMPLECTIC INTEGRATION

### Problem Statement

The original specification suggested Velocity-Verlet integration for the UFIE:

$$\frac{\partial^2 \Psi}{\partial t^2} + \alpha(1 - \hat{r}) \frac{\partial \Psi}{\partial t} - \frac{c_0^2}{(1 + \hat{s})^2} \nabla^2_g \Psi = \sum_{i=1}^8 \mathcal{E}_i(\vec{x}, t) + \beta |\Psi|^2 \Psi$$

**Issue:** The damping term $\alpha(1 - \hat{r}) \frac{\partial \Psi}{\partial t}$ is non-conservative. Standard Verlet methods assume Hamiltonian systems and fail to conserve energy in the presence of friction. This causes:
- Energy drift (memories vanish or explode exponentially)
- Numerical instability (system diverges within hours)
- Loss of standing waves (catastrophic "amnesia")

### Solution: Split-Operator Strang Splitting

Decompose the UFIE into three operators:

1. **Damping Operator:** $\hat{D} = -\gamma \frac{\partial}{\partial t}$ (dissipative)
2. **Conservative Operator:** $\hat{H} = \frac{\partial^2}{\partial t^2} - c^2 \nabla^2$ (Hamiltonian)
3. **Nonlinear Operator:** $\hat{N} = \beta |\Psi|^2 \Psi$ (conservative but nonlinear)

Apply Strang splitting for second-order accuracy:

$$e^{(\hat{D} + \hat{H} + \hat{N})\Delta t} \approx e^{\hat{D}\Delta t/2} e^{\hat{H}\Delta t/2} e^{\hat{N}\Delta t} e^{\hat{H}\Delta t/2} e^{\hat{D}\Delta t/2} + O(\Delta t^3)$$

### Implementation Algorithm

```cpp
void propagate_wave_split_operator(double dt) {
    const double dt_half = dt / 2.0;
    
    // Step 1: Half-kick damping (exact analytical solution)
    // v(t + dt/2) = v(t) * exp(-γ * dt/2)
    for (auto& node : active_nodes) {
        double gamma = alpha * (1.0 - node.resonance);  // Damping coefficient
        double decay = std::exp(-gamma * dt_half);
        node.psi_velocity *= decay;
    }
    
    // Step 2: Half-kick conservative force (Laplacian + emitters)
    // v(t + dt/2) += F(t) * dt/2
    compute_laplacian();  // Calculates ∇²Ψ
    for (auto& node : active_nodes) {
        double c_eff = c0 / std::pow(1.0 + node.state, 2);  // Effective speed
        std::complex<double> force = c_eff * c_eff * node.laplacian;
        force += emitter_field[node.index];  // External driving
        node.psi_velocity += force * dt_half;
    }
    
    // Step 3: Drift (update position)
    // Ψ(t + dt) = Ψ(t) + v(t + dt/2) * dt
    for (auto& node : active_nodes) {
        node.psi += node.psi_velocity * dt;
    }
    
    // Step 4: Apply nonlinear operator (implicit RK2 for stability)
    // Ψ(t + dt) = Ψ(t + dt) + β|Ψ|²Ψ * dt
    for (auto& node : active_nodes) {
        double magnitude_sq = std::norm(node.psi);
        node.psi += beta * magnitude_sq * node.psi * dt;
    }
    
    // Step 5: Half-kick force (recompute at new position)
    compute_laplacian();
    for (auto& node : active_nodes) {
        double c_eff = c0 / std::pow(1.0 + node.state, 2);
        std::complex<double> force = c_eff * c_eff * node.laplacian;
        force += emitter_field[node.index];
        node.psi_velocity += force * dt_half;
    }
    
    // Step 6: Half-kick damping (final decay)
    for (auto& node : active_nodes) {
        double gamma = alpha * (1.0 - node.resonance);
        double decay = std::exp(-gamma * dt_half);
        node.psi_velocity *= decay;
    }
}
```

### Mathematical Justification

**Symplectic Property:** The split-operator method preserves the symplectic structure of the Hamiltonian part, ensuring long-term energy conservation for the conservative terms.

**Exact Damping:** The analytical exponential decay for the damping operator ensures perfect energy dissipation without numerical drift.

**Stability:** Unconditionally stable for the linear terms. The nonlinear term requires $\Delta t < 1/(\beta |\Psi|_{\max})$, which is enforced by adaptive timestepping.

### Implementation Requirements

1. **Replace all Verlet code** with split-operator method
2. **CUDA kernel:** Implement as 6 separate kernel launches (allows device synchronization)
3. **Adaptive timestep:** Monitor $\max |\Psi|$ and reduce $\Delta t$ if it exceeds threshold
4. **Energy watchdog:** Compute total energy $E = \int (|\nabla \Psi|^2 + |\Psi|^2) dV$ every 100 steps, abort if drift exceeds 0.01%

**Priority:** P0 (Critical)  
**Timeline:** 3 days  
**Validation:** Energy conservation within 0.01% over 24-hour simulation

---

## 3. KAHAN COMPENSATED SUMMATION

### Problem Statement

The Laplacian operator in 9 dimensions involves summing contributions from neighbors. A standard finite difference stencil (27-point stencil in 3D, exponentially more in 9D) requires adding many small floating-point numbers to a potentially large accumulator.

**Issue:** In IEEE 754 floating-point arithmetic (FP32), adding a small number to a large number loses precision due to mantissa alignment ("absorption"). This causes:

- High-frequency, low-amplitude waves (subtle/distant memories) are numerically deleted
- System suffers "numerical amnesia"
- Loss of information in interference patterns

### Solution: Kahan Summation

Track low-order bits lost during addition using a compensation variable:

```cpp
struct KahanAccumulator {
    float sum = 0.0f;
    float correction = 0.0f;  // Stores lost low-order bits
    
    inline void add(float input) {
        float y = input - correction;         // Subtract previous correction
        float t = sum + y;                    // Add to sum (loses precision)
        correction = (t - sum) - y;           // Recover lost low-order bits
        sum = t;                              // Update sum
    }
};

// Usage in Laplacian kernel
void compute_laplacian_9d(const TorusGridSoA& grid, size_t node_idx) {
    KahanAccumulator acc_real, acc_imag;
    
    // Sum contributions from all 2×9 = 18 neighbors in 9D
    for (int dim = 0; dim < 9; ++dim) {
        size_t idx_plus = grid.neighbor_index(node_idx, dim, +1);
        size_t idx_minus = grid.neighbor_index(node_idx, dim, -1);
        
        // Second-order central difference: (ψ[i+1] - 2ψ[i] + ψ[i-1]) / h²
        float contrib_real = grid.psi_real[idx_plus] - 2.0f * grid.psi_real[node_idx] + grid.psi_real[idx_minus];
        float contrib_imag = grid.psi_imag[idx_plus] - 2.0f * grid.psi_imag[node_idx] + grid.psi_imag[idx_minus];
        
        acc_real.add(contrib_real);
        acc_imag.add(contrib_imag);
    }
    
    // Store final Laplacian result
    grid.laplacian_real[node_idx] = acc_real.sum;
    grid.laplacian_imag[node_idx] = acc_imag.sum;
}
```

### Mathematical Analysis

Standard floating-point addition accumulates error as $\epsilon_{\text{machine}} \times N$ where $N$ is the number of terms. For a 9D Laplacian with $N = 18$ neighbors:

- **Without Kahan:** Error $\sim 18 \times 10^{-7} \approx 2 \times 10^{-6}$ (FP32)
- **With Kahan:** Error $\sim 10^{-7}$ (near machine precision)

For standing wave patterns with amplitude ratios spanning 6 orders of magnitude (fundamental vs. harmonics), Kahan summation prevents catastrophic cancellation.

### Implementation Requirements

1. **All Laplacian kernels** must use Kahan accumulators
2. **All wave superposition operations** (>3 terms) must use Kahan summation
3. **Metric tensor updates** must use compensated summation
4. **Integration verification:** Test with manufactured solution having known high-frequency component

**Priority:** P0 (Critical)  
**Timeline:** 1 day  
**Validation:** Preserve 10⁻⁶ amplitude waves in presence of unit-amplitude carrier over 10⁶ timesteps

### Performance Impact

- **Stability:** Prevents divergence (critical for multi-hour runs)
- **Accuracy:** 2nd-order in time ($O(\Delta t^2)$ error)
- **Overhead:** ~20% slower than naive Verlet, but necessary for correctness

**Priority:** P0 (Critical)  
**Timeline:** 3 days  
**Validation:** Energy drift must be <0.0001% over 10,000 steps with standing wave test

---

## 3. KAHAN SUMMATION FOR LAPLACIAN

### Problem Statement

The Laplacian computation sums contributions from 18 neighbors in 9D:

$$\nabla^2 \Psi = \sum_{i=1}^{18} w_i (\Psi_{\text{neighbor}_i} - \Psi_{\text{center}})$$

With float32, summing 18 terms loses precision due to rounding errors. This causes:
- Gradual "smearing" of wave packets
- Loss of high-frequency components (fine details)
- Cumulative error accumulation ("amnesia" over days)

### Solution: Kahan Compensated Summation

```cpp
// ❌ FORBIDDEN: Naive summation loses precision
std::complex<float> laplacian = 0.0f;
for (auto& neighbor : neighbors) {
    laplacian += neighbor.psi;
}

// ✅ MANDATORY: Kahan summation preserves precision
std::complex<float> kahan_sum(const std::vector<std::complex<float>>& values) {
    std::complex<float> sum = 0.0f;
    std::complex<float> c = 0.0f;  // Compensation term
    
    for (const auto& val : values) {
        std::complex<float> y = val - c;    // Subtract previous error
        std::complex<float> t = sum + y;    // Add with low bits
        c = (t - sum) - y;                  // Recover rounding error
        sum = t;                            // Update sum
    }
    
    return sum;
}
```

### CUDA Implementation

```cuda
__device__ void kahan_add(float& sum, float& compensation, float value) {
    float y = value - compensation;
    float t = sum + y;
    compensation = (t - sum) - y;
    sum = t;
}

__global__ void compute_laplacian_kahan(float* psi_real, float* psi_imag, 
                                        float* laplacian_real, float* laplacian_imag,
                                        int* neighbor_indices, int num_nodes) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= num_nodes) return;
    
    float sum_real = 0.0f, c_real = 0.0f;
    float sum_imag = 0.0f, c_imag = 0.0f;
    
    // Sum contributions from 18 neighbors
    for (int n = 0; n < 18; n++) {
        int neighbor_idx = neighbor_indices[idx * 18 + n];
        float contrib_real = psi_real[neighbor_idx] - psi_real[idx];
        float contrib_imag = psi_imag[neighbor_idx] - psi_imag[idx];
        
        kahan_add(sum_real, c_real, contrib_real);
        kahan_add(sum_imag, c_imag, contrib_imag);
    }
    
    laplacian_real[idx] = sum_real;
    laplacian_imag[idx] = sum_imag;
}
```

### Implementation Requirements

1. **Replace all Laplacian summations** with Kahan algorithm
2. **CUDA kernels:** Use register-based compensation (no extra memory)
3. **AVX-512:** Implement vectorized Kahan sum for CPU fallback

### Performance Impact

- **Precision:** Reduces rounding error from $O(n \epsilon)$ to $O(\epsilon)$ where $n$ is number of terms
- **Overhead:** ~10% slower due to extra FP operations
- **Memory:** No additional storage (compensation is register-local)

**Priority:** P0 (Critical)  
**Timeline:** 1 day  
**Validation:** Standing wave must maintain amplitude to 6 decimal places over 1 million steps

---

## 4. AVX-512 NONARY ARITHMETIC

### Problem Statement

Balanced nonary arithmetic requires saturation at $\pm 4$. Standard CPU ALUs perform binary arithmetic, requiring explicit clamping after every operation.

Scalar implementation:

```cpp
// ❌ SLOW: Scalar saturation (200x slower than needed)
Nit add_nonary(Nit a, Nit b) {
    int result = static_cast<int>(a) + static_cast<int>(b);
    if (result > 4) return Nit::FOUR;
    if (result < -4) return Nit::NEG_FOUR;
    return static_cast<Nit>(result);
}
```

**Issue:** Processing 1M nits sequentially takes ~5ms. With SIMD, this can be reduced to ~25μs (200x speedup).

### Solution: AVX-512 Vectorization

```cpp
// ✅ MANDATORY: AVX-512 saturated nonary addition (64 nits per operation)
#include <immintrin.h>

void add_nonary_simd(const int8_t* a, const int8_t* b, int8_t* result, size_t count) {
    const __m512i limit_pos = _mm512_set1_epi8(4);   // Upper bound
    const __m512i limit_neg = _mm512_set1_epi8(-4);  // Lower bound
    
    size_t i = 0;
    for (; i + 64 <= count; i += 64) {
        // Load 64 nits
        __m512i va = _mm512_loadu_si512((__m512i*)(a + i));
        __m512i vb = _mm512_loadu_si512((__m512i*)(b + i));
        
        // Saturated addition (with hardware saturation at ±127)
        __m512i vsum = _mm512_adds_epi8(va, vb);
        
        // Clamp to [-4, 4] (nonary saturation)
        vsum = _mm512_min_epi8(vsum, limit_pos);
        vsum = _mm512_max_epi8(vsum, limit_neg);
        
        // Store result
        _mm512_storeu_si512((__m512i*)(result + i), vsum);
    }
    
    // Handle remaining elements (scalar fallback)
    for (; i < count; i++) {
        int sum = a[i] + b[i];
        result[i] = std::clamp(sum, -4, 4);
    }
}
```

### Multiplication via Lookup Table

Nonary multiplication requires heterodyning (wave mixing). For performance, use a precomputed 9×9 lookup table:

```cpp
// Precomputed nonary multiplication table
static constexpr int8_t NONARY_MUL_TABLE[9][9] = {
    // Row: multiplier value (-4 to 4), Column: multiplicand (-4 to 4)
    { 4,  3,  2,  1,  0, -1, -2, -3, -4},  // -4 × {...}
    { 3,  2,  1,  1,  0, -1, -1, -2, -3},  // -3 × {...}
    { 2,  1,  1,  0,  0,  0, -1, -1, -2},  // -2 × {...}
    { 1,  1,  0,  0,  0,  0,  0, -1, -1},  // -1 × {...}
    { 0,  0,  0,  0,  0,  0,  0,  0,  0},  //  0 × {...}
    {-1, -1,  0,  0,  0,  0,  0,  1,  1},  //  1 × {...}
    {-2, -1, -1,  0,  0,  0,  1,  1,  2},  //  2 × {...}
    {-3, -2, -1, -1,  0,  1,  1,  2,  3},  //  3 × {...}
    {-4, -3, -2, -1,  0,  1,  2,  3,  4},  //  4 × {...}
};

__m512i mul_nonary_simd(__m512i a, __m512i b) {
    // Use gather operation with lookup table
    // This requires AVX-512VBMI2 for efficient byte-level gather
    // Fallback: process 8 elements at a time with scalar lookup
    alignas(64) int8_t a_arr[64], b_arr[64], result[64];
    _mm512_store_si512((__m512i*)a_arr, a);
    _mm512_store_si512((__m512i*)b_arr, b);
    
    for (int i = 0; i < 64; i++) {
        int ai = a_arr[i] + 4;  // Convert [-4,4] to [0,8]
        int bi = b_arr[i] + 4;
        result[i] = NONARY_MUL_TABLE[ai][bi];
    }
    
    return _mm512_load_si512((__m512i*)result);
}
```

### Implementation Requirements

1. **CPU feature detection:** Check for AVX-512 support at runtime, fallback to scalar
2. **Memory alignment:** All nit arrays must be 64-byte aligned
3. **Compiler flags:** `-mavx512f -mavx512bw -mavx512vl`

### Performance Impact

- **Addition:** 200x speedup (64 nits per SIMD instruction vs 1 per scalar)
- **Multiplication:** ~50x speedup (lookup table is cache-friendly)
- **Total:** Nonary operations become negligible (<1% of runtime)

**Priority:** P1 (High)  
**Timeline:** 2 days  
**Validation:** Process 10M nonary additions in <50μs

---

## 5. LAZY CHOLESKY DECOMPOSITION FOR METRIC TENSOR

### Problem Statement

The metric tensor $g_{ij}$ is a 9×9 symmetric positive-definite matrix. To compute the Laplacian in curved space, we need:

$$\nabla^2 \Psi = g^{ij} \nabla_i \nabla_j \Psi$$

This requires inverting $g_{ij}$ to obtain $g^{ij}$. Naive matrix inversion (Gaussian elimination) is $O(n^3) = O(729)$ operations per node per timestep.

For 1M active nodes at 60 FPS:
- Operations: $1,000,000 \times 729 \times 60 = 4.4 \times 10^{10}$ per second
- Cost: ~100 CPU cores to maintain real-time (UNACCEPTABLE)

### Solution: Lazy Cholesky Decomposition with Caching

**Key Insight:** The metric tensor changes slowly (plasticity timescale is ~seconds). We can cache the decomposition and only recompute when the tensor changes significantly.

```cpp
class MetricTensorCache {
    std::array<double, 45> g_lower_triangle;  // Stored metric (symmetric)
    std::array<double, 45> L_cholesky;        // Cached Cholesky factor
    bool is_valid = false;
    double change_threshold = 1e-6;
    
public:
    // Check if metric has changed significantly
    bool needs_update(const std::array<double, 45>& new_g) const {
        double max_diff = 0.0;
        for (int i = 0; i < 45; i++) {
            max_diff = std::max(max_diff, std::abs(new_g[i] - g_lower_triangle[i]));
        }
        return max_diff > change_threshold;
    }
    
    // Update Cholesky decomposition (only when needed)
    void update_if_changed(const std::array<double, 45>& new_g) {
        if (!needs_update(new_g) && is_valid) {
            return;  // Use cached value
        }
        
        // Perform Cholesky decomposition: g = L * L^T
        // ... Cholesky algorithm (O(n³) but rare) ...
        
        g_lower_triangle = new_g;
        is_valid = true;
    }
    
    // Compute g^{-1} * v using forward/backward substitution (O(n²))
    std::array<double, 9> apply_inverse(const std::array<double, 9>& v) {
        // Solve L * y = v (forward substitution)
        std::array<double, 9> y;
        // ... O(n²) ...
        
        // Solve L^T * x = y (backward substitution)
        std::array<double, 9> x;
        // ... O(n²) ...
        
        return x;  // x = g^{-1} * v
    }
};
```

### Batch Update Strategy

For plasticity updates (which happen every ~1000 timesteps):

```cpp
void update_metric_batch() {
    // Identify nodes with changed metrics
    std::vector<size_t> dirty_nodes;
    for (size_t i = 0; i < active_nodes.size(); i++) {
        if (active_nodes[i].metric_dirty_flag) {
            dirty_nodes.push_back(i);
        }
    }
    
    // Parallel Cholesky decomposition (embarrassingly parallel)
    #pragma omp parallel for
    for (size_t idx : dirty_nodes) {
        active_nodes[idx].metric_cache.update_if_changed(
            active_nodes[idx].metric_tensor
        );
        active_nodes[idx].metric_dirty_flag = false;
    }
}
```

### Implementation Requirements

1. **Caching layer:** Add `MetricTensorCache` to `TorusNode` (or `TorusBlock` with SoA)
2. **Dirty flags:** Track which nodes have changed metrics
3. **Batch updates:** Update caches once per 1000 physics steps (not every step)
4. **Fallback:** For rapidly changing metrics, use direct inversion (rare case)

### Performance Impact

- **Speedup:** 100x for metric-related operations (amortized)
- **Cache hit rate:** >99% during steady-state operation
- **Memory overhead:** +360 bytes per node (Cholesky factor storage)

**Priority:** P1 (High)  
**Timeline:** 2 days  
**Validation:** Metric inversion overhead must be <5% of total runtime

---

## 6. SHARED MEMORY ZERO-COPY IPC

### Problem Statement

ZeroMQ serialization (Protocol Buffers) for high-frequency data (physics state at 60 FPS) introduces:
- Latency: ~100μs per frame (serialization + network stack)
- CPU overhead: ~10% (protobuf encoding/decoding)
- Memory allocation: frequent malloc/free causes fragmentation

For real-time visualization and memory systems, this is unacceptable.

### Solution: Shared Memory with Seqlock

```cpp
// Shared memory header (lives in /dev/shm/nikola_frame)
struct SharedFrame {
    // Seqlock for concurrency control
    std::atomic<uint64_t> sequence;  // Even = stable, Odd = writing
    
    // Metadata
    uint64_t timestamp_ns;
    uint32_t frame_number;
    uint32_t active_node_count;
    
    // Data payload (variable size)
    struct NodeState {
        uint64_t morton_code;  // Z-order index
        float psi_real, psi_imag;
        float energy_density;
    } nodes[];  // Flexible array member
};

// Writer (Physics Engine)
class SharedMemoryWriter {
    int shm_fd;
    SharedFrame* frame;
    size_t capacity;
    
public:
    void write_frame(const std::vector<NodeState>& nodes) {
        // 1. Increment sequence (mark as writing)
        uint64_t seq = frame->sequence.load(std::memory_order_acquire);
        frame->sequence.store(seq + 1, std::memory_order_release);
        
        // 2. Write data
        frame->timestamp_ns = get_timestamp_ns();
        frame->frame_number++;
        frame->active_node_count = nodes.size();
        std::memcpy(frame->nodes, nodes.data(), nodes.size() * sizeof(NodeState));
        
        // 3. Increment sequence again (mark as stable)
        frame->sequence.store(seq + 2, std::memory_order_release);
        
        // 4. Notify readers via tiny ZMQ message (8 bytes)
        zmq_send(notify_socket, &frame->frame_number, sizeof(uint32_t), ZMQ_DONTWAIT);
    }
};

// Reader (Visualizer)
class SharedMemoryReader {
    int shm_fd;
    const SharedFrame* frame;
    
public:
    std::optional<std::vector<NodeState>> read_frame() {
        uint64_t seq1, seq2;
        std::vector<NodeState> nodes;
        
        do {
            // Read sequence number (before)
            seq1 = frame->sequence.load(std::memory_order_acquire);
            if (seq1 & 1) continue;  // Writer is active, retry
            
            // Read data
            nodes.resize(frame->active_node_count);
            std::memcpy(nodes.data(), frame->nodes, 
                       frame->active_node_count * sizeof(NodeState));
            
            // Read sequence number (after)
            std::atomic_thread_fence(std::memory_order_acquire);
            seq2 = frame->sequence.load(std::memory_order_relaxed);
            
        } while (seq1 != seq2);  // Retry if data was modified during read
        
        return nodes;
    }
};
```

### Implementation Requirements

1. **Shared memory segment:** Allocate in `/dev/shm` (tmpfs, zero-copy)
2. **Size calculation:** Max frame size = `sizeof(SharedFrame) + MAX_ACTIVE_NODES * sizeof(NodeState)`
3. **ZMQ notification:** Use PUB-SUB pattern for frame-ready signals (no blocking)
4. **Cleanup:** Unlink shared memory on shutdown (`shm_unlink`)

### Performance Impact

- **Latency:** 100μs → 1μs (100x reduction)
- **Bandwidth:** No serialization overhead (direct memory access)
- **CPU:** 10% → 0.1% (no protobuf encoding)

**Priority:** P2 (Medium)  
**Timeline:** 2 days  
**Validation:** Visualizer must receive frames with <10μs latency jitter

---

## 7. 128-BIT MORTON CODES FOR Z-ORDER CURVES

### Problem Statement

Sparse grid hashing uses Z-order (Morton) curves to map 9D coordinates to linear indices. Standard implementation:

```cpp
// ❌ INSUFFICIENT: 64-bit keys cause collisions at high resolution
uint64_t morton_encode_9d(const std::array<uint16_t, 9>& coords) {
    // Each coordinate is 7 bits (max value 127)
    // Total: 9 × 7 = 63 bits (fits in uint64_t)
    // ...
}
```

**Issue:** This limits grid resolution to $128^9 \approx 10^{18}$ voxels. For detailed memory regions, we need $2^{14} = 16384$ voxels per dimension, requiring $9 \times 14 = 126$ bits.

**Consequence:** Hash collisions overwrite existing memories (data corruption).

### Solution: __int128_t Morton Codes

```cpp
// ✅ MANDATORY: 128-bit Morton codes (14 bits per dimension × 9 = 126 bits)
using MortonCode = __uint128_t;  // GCC/Clang extension

MortonCode morton_encode_9d(const std::array<uint16_t, 9>& coords) {
    MortonCode result = 0;
    
    for (int bit = 0; bit < 14; bit++) {
        for (int dim = 0; dim < 9; dim++) {
            // Extract bit from coordinate
            uint16_t coord_bit = (coords[dim] >> bit) & 1;
            
            // Place bit in Morton code
            int morton_bit_pos = bit * 9 + dim;
            result |= (static_cast<MortonCode>(coord_bit) << morton_bit_pos);
        }
    }
    
    return result;
}

std::array<uint16_t, 9> morton_decode_9d(MortonCode code) {
    std::array<uint16_t, 9> coords = {0};
    
    for (int bit = 0; bit < 14; bit++) {
        for (int dim = 0; dim < 9; dim++) {
            int morton_bit_pos = bit * 9 + dim;
            uint16_t coord_bit = (code >> morton_bit_pos) & 1;
            coords[dim] |= (coord_bit << bit);
        }
    }
    
    return coords;
}
```

### Hash Table Implementation

```cpp
#include <unordered_map>

// Custom hash function for __uint128_t
struct MortonHasher {
    size_t operator()(__uint128_t key) const {
        // XOR high and low 64 bits
        uint64_t low = static_cast<uint64_t>(key);
        uint64_t high = static_cast<uint64_t>(key >> 64);
        return std::hash<uint64_t>{}(low ^ high);
    }
};

// Sparse grid map
std::unordered_map<__uint128_t, TorusNodeProxy, MortonHasher> sparse_grid;
```

### Implementation Requirements

1. **Compiler support:** GCC/Clang only (MSVC uses `_BitInt(128)` in C++23)
2. **Serialization:** Split into two `uint64_t` for storage/transmission
3. **Overflow checks:** Assert coordinates are ≤ 16383 (14 bits)

### Performance Impact

- **Collision rate:** 100% → 0% (eliminates hash collisions)
- **Memory overhead:** 8 bytes → 16 bytes per key (acceptable)
- **Correctness:** CRITICAL (prevents data corruption)

**Priority:** P1 (High)  
**Timeline:** 1 day  
**Validation:** Insert 10M nodes with no collisions, verify retrieval

---

## 8. Q9_0 QUANTIZATION CORRECTION

### Problem Statement

The original spec suggested Q9_0 quantization packs 5 nits into `uint16_t`:
- $9^5 = 59,049 < 65,536$ ✅ Fits
- Storage: $16 / 5 = 3.2$ bits per nit

**Issue:** The encoding/decoding logic must handle the 9-ary radix conversion correctly. Naive implementation:

```cpp
// ❌ INCORRECT: Loses precision for large values
uint16_t encode_q9(const Nit nits[5]) {
    uint16_t result = 0;
    for (int i = 0; i < 5; i++) {
        int digit = static_cast<int>(nits[i]) + 4;  // Convert [-4,4] to [0,8]
        result = result * 9 + digit;  // Radix 9 accumulation
    }
    return result;
}
```

This works but loses the ability to index individual nits efficiently.

### Solution: Proper Radix Encoding

```cpp
// ✅ CORRECT: Radix-9 encoding with explicit powers
uint16_t encode_q9_0(const std::array<Nit, 5>& nits) {
    static constexpr uint16_t POWERS_OF_9[5] = {1, 9, 81, 729, 6561};
    
    uint16_t result = 0;
    for (int i = 0; i < 5; i++) {
        int digit = static_cast<int>(nits[i]) + 4;  // [-4,4] → [0,8]
        result += digit * POWERS_OF_9[i];
    }
    
    return result;
}

std::array<Nit, 5> decode_q9_0(uint16_t encoded) {
    static constexpr uint16_t POWERS_OF_9[5] = {1, 9, 81, 729, 6561};
    std::array<Nit, 5> nits;
    
    for (int i = 4; i >= 0; i--) {
        int digit = encoded / POWERS_OF_9[i];
        nits[i] = static_cast<Nit>(digit - 4);  // [0,8] → [-4,4]
        encoded %= POWERS_OF_9[i];
    }
    
    return nits;
}
```

### SIMD Batch Encoding

```cpp
// Encode 64 nits (12.8 uint16_t values) using AVX-512
void encode_q9_0_batch(const int8_t* nits, uint16_t* encoded, size_t count) {
    static constexpr int CHUNK_SIZE = 5;
    
    for (size_t i = 0; i + CHUNK_SIZE <= count; i += CHUNK_SIZE) {
        std::array<Nit, 5> chunk;
        std::memcpy(chunk.data(), nits + i, CHUNK_SIZE);
        encoded[i / CHUNK_SIZE] = encode_q9_0(chunk);
    }
    
    // Handle remainder
    // ...
}
```

### Implementation Requirements

1. **Validation:** Roundtrip test (encode → decode must match input)
2. **Bounds checking:** Assert nits are in [-4, 4] before encoding
3. **Alignment:** Pad to multiple of 5 nits for efficient SIMD processing

### Performance Impact

- **Storage:** 8 bits → 3.2 bits per nit (2.5x compression)
- **Speed:** Encoding/decoding is ~50ns per 5-nit block (negligible)

**Priority:** P2 (Medium)  
**Timeline:** 1 day  
**Validation:** 1M nit roundtrip test with 100% accuracy

---

## 9. VALIDATION AND MONITORING

### 9.1 Energy Watchdog

**Purpose:** Detect numerical instability by monitoring total system energy.

```cpp
class EnergyWatchdog {
    double initial_energy = 0.0;
    double tolerance = 1e-4;  // 0.01% drift allowed
    
public:
    void initialize(const TorusGrid& grid) {
        initial_energy = compute_total_energy(grid);
    }
    
    void check(const TorusGrid& grid, int step) {
        if (step % 100 != 0) return;  // Check every 100 steps
        
        double current_energy = compute_total_energy(grid);
        double drift = std::abs(current_energy - initial_energy) / initial_energy;
        
        if (drift > tolerance) {
            std::cerr << "CRITICAL: Energy drift " << drift * 100 << "% at step " 
                      << step << std::endl;
            std::cerr << "Initial: " << initial_energy 
                      << ", Current: " << current_energy << std::endl;
            std::abort();  // Fail fast
        }
    }
    
private:
    double compute_total_energy(const TorusGrid& grid) {
        double kinetic = 0.0, potential = 0.0;
        
        for (const auto& node : grid.active_nodes()) {
            // Kinetic energy: (1/2) * |∂Ψ/∂t|²
            kinetic += 0.5 * std::norm(node.psi_velocity);
            
            // Potential energy: (1/2) * |∇Ψ|² (computed via Laplacian)
            potential += 0.5 * std::norm(node.laplacian);
        }
        
        return kinetic + potential;
    }
};
```

### 9.2 Performance Profiler

**Purpose:** Identify bottlenecks in the physics loop.

```cpp
class PhysicsProfiler {
    std::unordered_map<std::string, std::chrono::nanoseconds> timings;
    
public:
    struct ScopedTimer {
        PhysicsProfiler& profiler;
        std::string name;
        std::chrono::steady_clock::time_point start;
        
        ScopedTimer(PhysicsProfiler& p, std::string n) 
            : profiler(p), name(std::move(n)), 
              start(std::chrono::steady_clock::now()) {}
        
        ~ScopedTimer() {
            auto elapsed = std::chrono::steady_clock::now() - start;
            profiler.record(name, elapsed);
        }
    };
    
    void record(const std::string& name, std::chrono::nanoseconds duration) {
        timings[name] += duration;
    }
    
    void print_report(int num_frames) {
        std::cout << "=== Physics Profiler ===" << std::endl;
        for (const auto& [name, total] : timings) {
            double avg_ms = total.count() / (1e6 * num_frames);
            std::cout << name << ": " << avg_ms << " ms/frame" << std::endl;
        }
    }
};

// Usage:
void physics_step() {
    PhysicsProfiler::ScopedTimer timer(profiler, "LaplacianCompute");
    compute_laplacian();
}
```

### 9.3 Correctness Tests

**Harmonic Oscillator Test:**

```cpp
void test_harmonic_oscillator() {
    // Initial condition: Gaussian wave packet
    // Ψ(x,0) = exp(-x²/2) * exp(ikx)
    
    // Expected: Oscillates with frequency ω = √(c² + k²)
    // Energy should remain constant
    
    // Run for 1000 cycles, check amplitude preservation
}
```

**Standing Wave Test:**

```cpp
void test_standing_wave() {
    // Initial: sin(πx/L) * sin(πy/L) pattern
    // Expected: Remains stationary (zero group velocity)
    
    // Run for 10,000 steps, check position stability
}
```

**Priority:** P1 (High)  
**Timeline:** Integrated into Phase 0 validation  
**Gate:** All tests must pass before Phase 1

---

## 10. PHASE 0 COMPLETION CHECKLIST

### P0 Tasks (Critical - 6 days)

- [ ] **Day 1-2:** Refactor `TorusNode` to SoA layout (`TorusBlock`)
  - [ ] Create `TorusBlock` struct with aligned arrays
  - [ ] Implement `TorusNodeProxy` accessor class
  - [ ] Update grid allocation code
  - [ ] Update CUDA kernels for coalesced access
  - [ ] **Validation:** Measure memory bandwidth (must achieve >80% of peak)

- [ ] **Day 3-5:** Implement Split-Operator Symplectic Integration
  - [ ] Replace Verlet with 6-step Strang splitting
  - [ ] Implement analytical damping decay
  - [ ] Add adaptive timestep control
  - [ ] **Validation:** Energy drift <0.0001% over 10K steps

- [ ] **Day 6:** Implement Kahan Summation for Laplacian
  - [ ] Update Laplacian accumulation loops
  - [ ] Add CUDA kernel with compensation
  - [ ] **Validation:** Standing wave amplitude stable to 6 decimals over 1M steps

### P1 Tasks (High - 6 days)

- [ ] **Day 7-8:** AVX-512 Nonary Arithmetic
  - [ ] Implement vectorized add/multiply
  - [ ] Create lookup tables
  - [ ] Add CPU feature detection
  - [ ] **Validation:** 10M operations in <50μs

- [ ] **Day 9-11:** Lazy Cholesky Decomposition
  - [ ] Add `MetricTensorCache` class
  - [ ] Implement dirty tracking
  - [ ] Add batch update logic
  - [ ] **Validation:** Metric overhead <5% of runtime

- [ ] **Day 12:** Energy Watchdog
  - [ ] Implement energy computation
  - [ ] Add periodic checks
  - [ ] **Validation:** Detect artificial drift injection

### P2 Tasks (Medium - 5 days)

- [ ] **Day 13-14:** Shared Memory IPC
  - [ ] Create seqlock implementation
  - [ ] Allocate `/dev/shm` segment
  - [ ] Integrate with ZMQ notifications
  - [ ] **Validation:** <10μs latency jitter

- [ ] **Day 15-16:** Mamba Taylor Approximation
  - [ ] Implement first-order matrix approximation
  - [ ] Add adaptive timestep
  - [ ] **Validation:** 10x speedup vs full matrix exp

- [ ] **Day 17:** Q9_0 Quantization
  - [ ] Implement radix-9 encoding
  - [ ] Add batch SIMD encoder
  - [ ] **Validation:** 1M roundtrip with 100% accuracy

### Gate Review

**Criteria for Phase 1 Entry:**
1. ✅ All P0 and P1 tasks complete
2. ✅ All validation tests pass
3. ✅ Energy watchdog operational
4. ✅ Physics step <1ms on sparse 27³ grid
5. ✅ Code review completed (2 engineer sign-off)

**If gate fails:** Remediation continues until all criteria met. NO EXCEPTIONS.

---

## CONCLUSION

Phase 0 remediation is **non-negotiable**. The original specification contained latent defects that would cause catastrophic failure in production. These fixes transform the system from a theoretical model into a production-ready implementation.

**Expected Outcome:** After Phase 0, the physics engine will:
- Run stably for days without divergence
- Achieve real-time performance on commodity hardware
- Preserve memory precision over millions of cycles
- Provide a solid foundation for cognitive layer development

**Next Steps:** Upon successful gate review, proceed to Phase 1 (Core Physics Engine) with confidence that the foundation is mathematically sound and computationally stable.
# FILE STRUCTURE

## 26.0 Phase 0 Critical Components

**Date:** December 7, 2025  
**Source:** Engineering Report Review and Analysis v0.0.4

The file structure has been updated to include Phase 0 critical components. Key additions:

- `include/nikola/physics/soa_layout.hpp` - Structure-of-Arrays memory layout
- `include/nikola/physics/symplectic_integrator.hpp` - Split-operator integration
- `include/nikola/security/physics_oracle.hpp` - Self-improvement safety
- `src/physics/kernels/wave_propagate_soa.cu` - SoA CUDA kernel
- `tests/validation/` - Phase 0 validation test suite

See: `08_audit_remediation/01_critical_fixes.md` for complete specifications.

---

## 26.1 Complete Directory Organization

```
nikola/
├── CMakeLists.txt                   # Root CMake file
├── README.md                        # Project README
├── LICENSE                          # License file
├── .dockerignore                    # Docker ignore
├── Dockerfile                       # Multi-stage Docker build
├── docker-compose.yml               # Service orchestration
│
├── include/                         # Public headers
│   └── nikola/
│       ├── types/
│       │   ├── nit.hpp              # Balanced nonary type (AVX-512)
│       │   ├── coord9d.hpp          # 9D coordinate
│       │   ├── torus_node.hpp       # Node structure (DEPRECATED - use SoA)
│       │   ├── torus_block.hpp      # ⚡ SoA memory layout (Phase 0)
│       │   └── morton_code.hpp      # ⚡ 128-bit Z-order encoding (Phase 0)
│       ├── physics/
│       │   ├── torus_manifold.hpp   # Main 9D grid
│       │   ├── soa_layout.hpp       # ⚡ Structure-of-Arrays (Phase 0)
│       │   ├── symplectic_integrator.hpp # ⚡ Split-operator (Phase 0)
│       │   ├── kahan_sum.hpp        # ⚡ Compensated summation (Phase 0)
│       │   ├── emitter_array.hpp    # DDS emitters
│       │   ├── wave_engine.hpp      # Interference processor
│       │   ├── shvo_grid.hpp        # Sparse hyper-voxel
│       │   ├── metric.hpp           # Riemannian geometry
│       │   └── metric_cache.hpp     # ⚡ Lazy Cholesky (Phase 0)
│       ├── mamba/
│       │   ├── hilbert_scan.hpp     # Space-filling curve
│       │   ├── ssm_kernel.hpp       # State space model
│       │   └── taylor_approx.hpp    # ⚡ Matrix approximation (Phase 0)
│       ├── reasoning/
│       │   ├── transformer.hpp      # Wave transformer
│       │   ├── attention.hpp        # Wave correlation
│       │   └── embedder.hpp         # Nonary embedder
│       ├── spine/
│       │   ├── broker.hpp           # ZeroMQ router
│       │   ├── component_client.hpp # Client interface
│       │   ├── shadow_spine.hpp     # A/B testing
│       │   └── shared_memory.hpp    # ⚡ Zero-copy IPC (Phase 0)
│       ├── agents/
│       │   ├── tavily.hpp           # Search client
│       │   ├── firecrawl.hpp        # Scrape client
│       │   ├── gemini.hpp           # Translation client
│       │   └── http_client.hpp      # Custom HTTP
│       ├── executor/
│       │   └── kvm_executor.hpp     # VM manager
│       ├── autonomy/
│       │   ├── dopamine.hpp         # Reward system
│       │   ├── engs.hpp             # Extended neurochemistry
│       │   ├── boredom.hpp          # Curiosity
│       │   ├── goals.hpp            # Goal DAG
│       │   └── dream_weave.hpp      # Counterfactual learning
│       ├── persistence/
│       │   ├── dmc.hpp              # Checkpoint manager
│       │   ├── lsm_dmc.hpp          # LSM persistence
│       │   ├── gguf_export.hpp      # GGUF converter
│       │   ├── q9_encoder.hpp       # ⚡ Q9_0 quantization (Phase 0)
│       │   └── identity.hpp         # Identity profile
│       ├── multimodal/
│       │   ├── audio_resonance.hpp  # Audio FFT
│       │   └── visual_cymatics.hpp  # Image processing
│       ├── security/
│       │   ├── resonance_firewall.hpp # Attack detection
│       │   ├── physics_oracle.hpp   # ⚡ Self-improvement safety (Phase 0)
│       │   ├── adversarial_dojo.hpp # ⚡ Red team testing (Phase 0)
│       │   └── csvp.hpp             # Code safety protocol
│       ├── monitoring/
│       │   ├── energy_watchdog.hpp  # ⚡ Energy conservation monitor (Phase 0)
│       │   └── profiler.hpp         # ⚡ Performance profiler (Phase 0)
│       └── self_improve/
│           └── hot_swap.hpp         # Module replacement
│
├── src/                             # Implementation
│   ├── core/
│   │   ├── lib9dtwi.cpp             # Main library
│   │   └── CMakeLists.txt
│   ├── types/
│   │   ├── nit.cpp                  # ⚡ AVX-512 nonary ops (Phase 0)
│   │   ├── coord9d.cpp
│   │   ├── torus_block.cpp          # ⚡ SoA implementation
│   │   ├── morton_code.cpp          # ⚡ 128-bit encoding
│   │   └── CMakeLists.txt
│   ├── physics/
│   │   ├── torus_manifold.cpp
│   │   ├── soa_layout.cpp           # ⚡ SoA refactoring
│   │   ├── symplectic_integrator.cpp # ⚡ 6-step Strang splitting
│   │   ├── kahan_sum.cpp            # ⚡ Compensated summation
│   │   ├── emitter_array.cpp
│   │   ├── wave_engine.cpp
│   │   ├── shvo_grid.cpp
│   │   ├── metric.cpp
│   │   ├── metric_cache.cpp         # ⚡ Lazy Cholesky
│   │   ├── kernels/                 # CUDA kernels
│   │   │   ├── wave_propagate.cu    # Original (DEPRECATED)
│   │   │   ├── wave_propagate_soa.cu # ⚡ SoA coalesced (Phase 0)
│   │   │   └── laplacian_kahan.cu   # ⚡ Kahan CUDA kernel
│   │   └── CMakeLists.txt
│   ├── mamba/
│   │   ├── hilbert_scan.cpp
│   │   ├── ssm_kernel.cpp
│   │   ├── taylor_approx.cpp        # ⚡ First-order matrix approx
│   │   └── CMakeLists.txt
│   ├── reasoning/
│   │   ├── transformer.cpp
│   │   ├── wave_attention.cpp
│   │   ├── embedder.cpp
│   │   └── CMakeLists.txt
│   ├── spine/
│   │   ├── broker.cpp
│   │   ├── component_client.cpp
│   │   ├── shadow_spine.cpp
│   │   ├── shared_memory.cpp        # ⚡ Seqlock IPC
│   │   └── CMakeLists.txt
│   ├── orchestrator/
│   │   ├── smart_router.cpp
│   │   └── CMakeLists.txt
│   ├── agents/
│   │   ├── tavily.cpp
│   │   ├── firecrawl.cpp
│   │   ├── gemini.cpp
│   │   ├── http_client.cpp
│   │   └── CMakeLists.txt
│   ├── executor/
│   │   ├── kvm_executor.cpp
│   │   ├── guest_agent.cpp          # Runs inside VM
│   │   └── CMakeLists.txt
│   ├── autonomy/
│   │   ├── dopamine.cpp
│   │   ├── engs.cpp
│   │   ├── boredom.cpp
│   │   ├── goals.cpp
│   │   ├── trainers.cpp
│   │   ├── dream_weave.cpp
│   │   └── CMakeLists.txt
│   ├── persistence/
│   │   ├── dmc.cpp
│   │   ├── lsm_dmc.cpp
│   │   ├── gguf_export.cpp
│   │   ├── q9_encoder.cpp           # ⚡ Radix-9 encoding
│   │   ├── identity.cpp
│   │   └── CMakeLists.txt
│   ├── multimodal/
│   │   ├── audio_resonance.cpp
│   │   ├── visual_cymatics.cpp
│   │   └── CMakeLists.txt
│   ├── security/
│   │   ├── resonance_firewall.cpp
│   │   ├── physics_oracle.cpp       # ⚡ Mathematical verification
│   │   ├── adversarial_dojo.cpp     # ⚡ Attack testing
│   │   ├── csvp.cpp
│   │   └── CMakeLists.txt
│   ├── monitoring/
│   │   ├── energy_watchdog.cpp      # ⚡ Conservation checks
│   │   ├── profiler.cpp             # ⚡ Performance tracking
│   │   └── CMakeLists.txt
│   ├── self_improve/
│   │   ├── hot_swap.cpp
│   │   └── CMakeLists.txt
│   └── ingestion/
│       ├── sentinel.cpp
│       └── CMakeLists.txt
│
├── tools/                           # Utilities
│   ├── twi-ctl/
│   │   ├── main.cpp                 # CLI controller
│   │   └── CMakeLists.txt
│   ├── validate_phase0/             # ⚡ Phase 0 validation (Phase 0)
│   │   ├── test_energy_conservation.cpp
│   │   ├── test_symplectic.cpp
│   │   ├── test_kahan.cpp
│   │   └── CMakeLists.txt
│   └── convert_nikola_to_gguf.py    # GGUF export script
│
├── proto/                           # Protocol Buffers
│   ├── neural_spike.proto
│   └── CMakeLists.txt
│
├── tests/                           # Test suites
│   ├── validation/                  # ⚡ Phase 0 validation suite (Phase 0)
│   │   ├── test_energy_conservation.cpp
│   │   ├── test_symplectic_property.cpp
│   │   ├── test_kahan_summation.cpp
│   │   ├── test_wave_equation.cpp
│   │   ├── test_boundary_wrapping.cpp
│   │   └── test_numerical_stability.cpp
│   ├── unit/
│   │   ├── test_nit.cpp
│   │   ├── test_coord9d.cpp
│   │   ├── test_emitter_array.cpp
│   │   └── CMakeLists.txt
│   └── integration/
│       ├── test_wave_propagation.cpp
│       ├── test_mamba_ssm.cpp
│       └── CMakeLists.txt
│
├── config/                          # Configuration files
│   ├── default.toml                 # Default system config
│   ├── physics_constants.toml       # Physical parameters
│   ├── hazards.db                   # Resonance firewall patterns
│   └── keys/                        # CurveZMQ keys (generated)
│       ├── public.key
│       └── secret.key
│
└── docs/                            # Documentation
    ├── architecture.md
    ├── api_reference.md
    ├── phase0_validation.md         # ⚡ Phase 0 checklist
    └── integration/                 # This documentation set

## 26.2 Implementation Guide - Mandated Organization

**CRITICAL:** To avoid "creative" organization, the engineering team MUST adhere to this exact directory mapping, which corresponds to architectural layers:

```
/src
  /core
    main.cpp              # Entry point, orchestrator initialization
    config_loader.cpp     # JSON/TOML configuration parsing
    
  /physics                # The 9D Substrate Layer
    torus_grid_soa.hpp    # ⚡ SoA Data Structure (The Substrate)
    integrator.cpp        # ⚡ Symplectic Split-Operator Solver
    ufie_kernels.cu       # CUDA Kernels for Laplacian/Nonlinearity
    kahan_sum.cpp         # ⚡ Compensated Summation
    shvo_grid.cpp         # Sparse Hyper-Voxel Octree logic
    metric.cpp            # Metric tensor operations
    emitter_array.cpp     # Golden ratio DDS emitters
    
  /cognitive              # The Cognitive Processing Layer
    mamba_tsm.cpp         # ⚡ TSM (Topology→Matrix mapper)
    transformer_np.cpp    # Neuroplastic Wave Attention
    hilbert_curve.cpp     # BMI2-optimized Hilbert scanning
    embedder.cpp          # Balanced nonary text encoder
    
  /autonomy               # The Autonomous Systems Layer
    engs_system.cpp       # Neurochemistry state machine
    dream_weave.cpp       # Counterfactual simulation engine
    dopamine.cpp          # Reward/learning modulation
    boredom.cpp           # Curiosity-driven exploration
    
  /infrastructure         # The Communication Backbone
    spine_broker.cpp      # ZeroMQ Router implementation
    kvm_manager.cpp       # Libvirt interface for Executors
    shared_memory.cpp     # ⚡ Seqlock zero-copy IPC
    proto/                # Compiled Protocol Buffers (.pb.cc)
    
  /types                  # The Arithmetic Foundation
    nit_avx512.cpp        # ⚡ Optimized Nonary Arithmetic (AVX-512)
    geometry.hpp          # 9D Coordinate utilities
    morton_code.cpp       # ⚡ 128-bit Z-order encoding
    
  /security               # The Safety and Validation Layer
    physics_oracle.cpp    # ⚡ Mathematical verification sandbox
    adversarial_dojo.cpp  # ⚡ Red team attack testing
    resonance_firewall.cpp # Spectral input filtering
    
  /persistence            # The Memory Durability Layer
    dmc.cpp               # Delta Memory Compression checkpoints
    lsm_dmc.cpp           # Log-Structured Merge persistence
    gguf_export.cpp       # Llama.cpp interoperability
    q9_encoder.cpp        # ⚡ Nonary quantization (Q9_0)
    
  /monitoring             # The Observability Layer
    energy_watchdog.cpp   # ⚡ Runtime conservation checks
    profiler.cpp          # ⚡ Performance tracking
```

### 26.2.1 Phase 0 Implementation Checklist (17-Day Sprint)

**Critical Path - Immediate Engineering Tasks:**

**Days 1-2:** Structure-of-Arrays Refactoring
- [ ] Create `include/nikola/physics/torus_grid_soa.hpp`
- [ ] Implement `TorusGridSoA` with 64-byte aligned vectors
- [ ] Implement 45-component metric tensor storage (upper triangular)
- [ ] Create `TorusNodeProxy` accessor class for API compatibility
- [ ] Refactor all grid access code to use proxy pattern
- [ ] Update CUDA kernels for coalesced memory access
- [ ] Validation: Physics kernel achieves <1ms per step on 27³ grid

**Days 3-5:** Split-Operator Symplectic Integration
- [ ] Create `include/nikola/physics/symplectic_integrator.hpp`
- [ ] Implement 6-step Strang splitting:
  - Half-kick damping (analytical exponential decay)
  - Half-kick conservative force (Laplacian + emitters)
  - Full drift (position update)
  - Nonlinear operator (RK2 implicit)
  - Half-kick force (recompute at new position)
  - Half-kick damping (final decay)
- [ ] Replace all Velocity-Verlet code
- [ ] Implement adaptive timestep monitoring
- [ ] Implement energy watchdog (compute Hamiltonian every 100 steps)
- [ ] Validation: Energy conservation within 0.01% over 24 hours

**Day 6:** Kahan Compensated Summation
- [ ] Create `include/nikola/physics/kahan_sum.hpp`
- [ ] Implement `KahanAccumulator` struct
- [ ] Refactor all Laplacian kernels to use Kahan summation
- [ ] Refactor all wave superposition operations
- [ ] Refactor metric tensor updates
- [ ] Validation: Preserve 10⁻⁶ amplitude waves over 10⁶ timesteps

**Day 7:** 128-bit Morton Code Hashing
- [ ] Create `include/nikola/types/morton_code.hpp`
- [ ] Implement BMI2-optimized bit interleaving
- [ ] Implement collision detection and double-hashing fallback
- [ ] Replace existing 64-bit Morton codes
- [ ] Validation: Zero collisions on 10⁷ random 9D coordinates

**Day 8:** Vectorized Nonary Arithmetic
- [ ] Create `include/nikola/types/nit_avx512.hpp`
- [ ] Implement `vec_sum_gate_avx512()` (64 trits parallel)
- [ ] Implement `vec_product_gate_avx512()` (heterodyning)
- [ ] Refactor all nonary operations to use SIMD
- [ ] Validation: 10x speedup vs scalar implementation

**Days 9-11:** Topological State Mapping (TSM)
- [ ] Create `src/cognitive/mamba_tsm.cpp`
- [ ] Implement `tsm_generate_parameters_kernel()`
- [ ] Extract metric tensor → Matrix A conversion
- [ ] Extract state dimension → Matrix B conversion
- [ ] Integrate with Hilbert curve scanner
- [ ] Validation: Mamba layers dynamically respond to metric changes

**Days 12-14:** Physics Oracle & Adversarial Dojo
- [ ] Create `include/nikola/security/physics_oracle.hpp`
- [ ] Implement 5 verification tests:
  - Energy conservation
  - Symplectic property
  - Wave equation validity
  - Boundary conditions (toroidal wrapping)
  - Numerical stability (NaN/Inf detection)
- [ ] Create `include/nikola/security/adversarial_dojo.hpp`
- [ ] Implement 10+ attack vectors
- [ ] Implement hot-swap protocol with Oracle gate
- [ ] Implement runtime energy watchdog
- [ ] Validation: All tests pass; attacks fail; 24-hour stability

**Days 15-16:** Integration & Testing
- [ ] Run full Phase 0 validation suite
- [ ] Profile memory bandwidth (should saturate DDR5)
- [ ] Profile energy conservation (should be <0.01% drift)
- [ ] Profile Laplacian accuracy (should preserve 10⁻⁶ amplitudes)
- [ ] Fix any identified issues

**Day 17:** Documentation & Handoff
- [ ] Document all Phase 0 implementations
- [ ] Create performance benchmark report
- [ ] Update README with Phase 0 status
- [ ] Tag repository as `v0.0.4-phase0-complete`

**Gate Requirement:** ALL checklist items must pass validation before Phase 1 begins.

**Final Directive:** Do not proceed to higher-level cognitive features until Physics Oracle confirms energy stability for >24 hours of continuous operation.

---

**Cross-References:**
- See `08_phase_0_requirements/01_critical_fixes.md` for detailed specifications
- See `11_appendices/04_hardware_optimization.md` for AVX-512 requirements
- See `09_implementation/03_implementation_checklist.md` for complete task list
│   ├── unit/
│   │   ├── test_nonary.cpp
│   │   ├── test_coord9d.cpp
│   │   ├── test_wave_interference.cpp
│   │   ├── test_hilbert.cpp
│   │   ├── test_engs.cpp
│   │   ├── test_neuroplasticity.cpp
│   │   └── CMakeLists.txt
│   ├── integration/
│   │   ├── test_search_retrieve.cpp
│   │   ├── test_training.cpp
│   │   ├── test_multimodal.cpp
│   │   └── CMakeLists.txt
│   └── benchmarks/
│       ├── bench_propagation.cpp
│       ├── bench_hilbert.cpp
│       └── CMakeLists.txt
│
├── docker/                          # Docker files
│   ├── Dockerfile.base              # Base image
│   ├── Dockerfile.runtime           # Runtime image
│   └── gold-image/                  # VM gold image
│       └── ubuntu-24.04.qcow2
│
├── config/                          # Configuration
│   ├── nikola.conf                  # Main config
│   ├── emitters.conf                # Frequency settings
│   └── security.conf                # Firewall patterns
│
└── docs/                            # Documentation
    ├── architecture.md
    ├── api_reference.md
    └── troubleshooting.md
```

## 26.2 File Manifest

**Total Files:** ~150
**Total Lines of Code (estimated):** ~50,000

**Critical Path Files (Must implement first):**

1. `include/nikola/types/nit.hpp` - Balanced nonary enum
2. `include/nikola/types/torus_node.hpp` - Node structure
3. `include/nikola/physics/torus_manifold.hpp` - Grid
4. `include/nikola/physics/emitter_array.hpp` - DDS
5. `src/physics/wave_engine.cpp` - Interference processor
6. `proto/neural_spike.proto` - Message protocol
7. `src/spine/broker.cpp` - Communication backbone

## 26.3 Key Implementation Files by Subsystem

### Physics Engine (Core)
- `types/nit.hpp/cpp` - Balanced nonary arithmetic
- `physics/torus_manifold.hpp/cpp` - 9D sparse grid
- `physics/emitter_array.hpp/cpp` - Golden ratio DDS
- `physics/wave_engine.cpp` - Superposition/heterodyning
- `physics/shvo_grid.cpp` - Sparse hyper-voxel octree
- `physics/kernels/wave_propagate.cu` - CUDA acceleration

### Cognitive Systems
- `mamba/hilbert_scan.cpp` - Space-filling curve scanner
- `mamba/ssm_kernel.cpp` - State space model
- `reasoning/transformer.cpp` - Neuroplastic transformer
- `reasoning/wave_attention.cpp` - Wave correlation
- `reasoning/embedder.cpp` - Text-to-waveform

### Infrastructure
- `spine/broker.cpp` - ZeroMQ message router
- `spine/shadow_spine.cpp` - A/B testing infrastructure
- `orchestrator/smart_router.cpp` - Tool selection
- `agents/*.cpp` - External API clients
- `executor/kvm_executor.cpp` - Sandboxed execution

### Autonomy
- `autonomy/engs.cpp` - Extended neurochemistry
- `autonomy/dopamine.cpp` - Reward system
- `autonomy/boredom.cpp` - Curiosity-driven learning
- `autonomy/goals.cpp` - Hierarchical goal DAG
- `autonomy/dream_weave.cpp` - Counterfactual simulation
- `autonomy/trainers.cpp` - Autonomous training

### Persistence & Safety
- `persistence/lsm_dmc.cpp` - Log-structured persistence
- `persistence/gguf_export.cpp` - GGUF interoperability
- `security/resonance_firewall.cpp` - Attack detection
- `security/csvp.cpp` - Code safety verification
- `self_improve/adversarial_dojo.cpp` - Red team testing

### Multimodal
- `multimodal/audio_resonance.cpp` - FFT-based audio
- `multimodal/visual_cymatics.cpp` - Holographic vision

---

**Cross-References:**
- See Section 27 for Development Roadmap
- See Section 28 for Implementation Checklist
- See Appendices for build system details
# DEVELOPMENT ROADMAP

## 🚨 CRITICAL: Engineering Phase 0 Requirements Required

**Date:** December 7, 2025  
**Source:** Engineering Report Review and Analysis v0.0.4  
**Status:** MANDATORY - NO CODE UNTIL COMPLETE  
**Classification:** PHASE 0 - CRITICAL FIXES

A comprehensive engineering analysis identified critical implementation gaps that **MUST** be addressed before any feature development. These are not optimizations—they are functional requirements to prevent:

- **Numerical Instability:** System divergence within hours (energy drift)
- **Memory Thrashing:** 90% cache miss rate → 100x performance loss
- **Precision Loss:** Float32 errors cause "amnesia" over time
- **Hash Collisions:** Memory corruption in high-resolution grids
- **Race Conditions:** GPU segfaults and data corruption

**See:** `08_audit_remediation/01_critical_fixes.md` for complete specifications

---

## Phase 0: Critical Remediation (Weeks 1-2, 17 days)

**⚠️ NO DEVIATION:** All Phase 0 fixes are mandatory architectural requirements.

### Priority P0 (Critical - 6 days)

| Day | Task | Reference | Impact | Validation |
|-----|------|-----------|--------|------------|
| 1-2 | **SoA Memory Layout** | §1 Critical Fixes | 10x performance | >80% memory bandwidth utilization |
| | - Refactor `TorusNode` → `TorusBlock` | | | |
| | - Implement `TorusNodeProxy` | | | |
| | - Update CUDA kernels for coalesced access | | | |
| 3-5 | **Split-Operator Integration** | §2 Critical Fixes | Prevents divergence | Energy drift <0.0001% over 10K steps |
| | - Replace Verlet with Strang splitting | | | |
| | - Implement analytical damping decay | | | |
| | - Add adaptive timestep control | | | |
| 6 | **Kahan Summation** | §2.4 Critical Fixes | Prevents amnesia | Amplitude stable to 6 decimals over 1M steps |
| | - Update Laplacian accumulation | | | |
| | - CUDA kernel with compensation | | | |

### Priority P1 (High - 6 days)

| Day | Task | Reference | Impact | Validation |
|-----|------|-----------|--------|------------|
| 7-8 | **AVX-512 Nit Operations** | §4 Critical Fixes | 200x speedup | 10M ops in <50μs |
| | - Vectorized add/multiply (64 nits/op) | | | |
| | - Lookup tables for multiplication | | | |
| | - CPU feature detection + fallback | | | |
| 9-11 | **Lazy Cholesky Decomposition** | §5 Critical Fixes | 100x speedup | Metric overhead <5% runtime |
| | - Add `MetricTensorCache` class | | | |
| | - Implement dirty tracking | | | |
| | - Batch update logic | | | |
| 12 | **Energy Watchdog** | §9.1 Critical Fixes | System stability | Detect drift injection |
| | - Energy computation | | | |
| | - Periodic checks (every 100 steps) | | | |

### Priority P2 (Medium - 5 days)

| Day | Task | Reference | Impact | Validation |
|-----|------|-----------|--------|------------|
| 13-14 | **Shared Memory IPC** | §6.3 Critical Fixes | 1000x latency reduction | <10μs jitter |
| | - Seqlock implementation | | | |
| | - `/dev/shm` allocation | | | |
| | - ZMQ notifications | | | |
| 15-16 | **Mamba Taylor Approximation** | §3 Critical Fixes | 10x speedup | Compare vs full matrix exp |
| | - First-order matrix approximation | | | |
| | - Adaptive timestep | | | |
| 17 | **Q9_0 Quantization** | §8 Critical Fixes | 2x storage efficiency | 1M roundtrip 100% accuracy |
| | - Radix-9 encoding | | | |
| | - Batch SIMD encoder | | | |

### Phase 0 Gate Review

**Criteria for Phase 1 Entry:**
- ✅ All P0 and P1 tasks complete
- ✅ All validation tests pass
- ✅ Energy watchdog operational
- ✅ Physics step <1ms on sparse 27³ grid
- ✅ Code review completed (2 engineer sign-off)

**If gate fails:** Remediation continues until all criteria met. **NO EXCEPTIONS.**

**Total Critical Path:** 17 days (3.5 weeks)

---

## 27.1 Phase 1: Core Physics Engine (Months 1-3)

**Milestone:** Standing waves propagate correctly in 9D

**Tasks:**

| Week | Task | Deliverable |
|------|------|-------------|
| 1-2 | Implement `Nit` enum and nonary arithmetic | Unit tests pass |
| 3-4 | Implement `TorusNode` structure with metric tensor | Structure defined |
| 5-6 | Implement sparse `TorusManifold` grid (SHVO) | Grid can be created |
| 7-8 | Implement `EmitterArray` with DDS | Emitters generate signals |
| 9-10 | Implement wave propagation kernel | Waves propagate |
| 11-12 | Optimize with AVX-512/CUDA | Performance targets met |

**Validation Criteria:**

- [ ] Nonary addition: $1 + (-1) = 0$
- [ ] Wave superposition creates interference patterns
- [ ] Energy conserved over 1000 time steps
- [ ] Performance: <1ms per physics step (sparse 27³ grid)
- [ ] Toroidal wrapping works correctly

## 27.2 Phase 2: Logic and Memory (Months 4-6)

**Milestone:** Store text as wave, retrieve via resonance

**Tasks:**

| Week | Task | Deliverable |
|------|------|-------------|
| 13-14 | Implement balanced nonary arithmetic gates | Gates work |
| 15-16 | Build `NonaryEmbedder` (text → wave) | Embedder functional |
| 17-18 | Integrate LMDB storage backend | DB stores/loads nodes |
| 19-20 | Implement search-retrieve-store loop | Basic memory works |
| 21-22 | Implement LSM-DMC persistence (.nik format) | State persists |
| 23-24 | Validate memory accuracy over sessions | Retrieval >90% accurate |

**Validation Criteria:**

- [ ] Text → Waveform → Text roundtrip works
- [ ] Resonance detection finds stored patterns
- [ ] LSM-DMC saves and loads state correctly
- [ ] Merkle tree detects corruption
- [ ] Nap consolidation triggers correctly

## 27.3 Phase 3: The Brain (Months 7-9)

**Milestone:** System demonstrates learning

**Tasks:**

| Week | Task | Deliverable |
|------|------|-------------|
| 25-26 | Implement Mamba-9D Hilbert scanner | Scanner works |
| 27-28 | Port Transformer to Wave Correlation | Transformer operational |
| 29-30 | Implement Neuroplasticity (metric updates) | Learning observable |
| 31-32 | Implement Neurogenesis (grid expansion) | Grid grows when needed |
| 33-34 | Build autonomous trainers (BAT) | Training runs automatically |
| 35-36 | Benchmark retrieval accuracy improvements | Accuracy improves >10% |

**Validation Criteria:**

- [ ] Hilbert scan visits all nodes
- [ ] Wave correlation attention works
- [ ] Metric tensor contracts with co-activation
- [ ] New nodes created when saturated
- [ ] Repeated queries answered faster
- [ ] Topological State Mapping functional

## 27.4 Phase 4: Integration and Agents (Months 10-11)

**Milestone:** Full autonomous system

**Tasks:**

| Week | Task | Deliverable |
|------|------|-------------|
| 37-38 | Build ZeroMQ Spine with CurveZMQ security | Spine operational |
| 39-40 | Integrate Tavily/Firecrawl/Gemini APIs | Agents work |
| 41-42 | Implement KVM Executor with libvirt | VMs spawn and execute |
| 43-44 | Build twi-ctl CLI controller | CLI functional |
| 45-46 | Implement auto-ingestion pipeline (inotify) | Files ingested automatically |
| 47-48 | Finalize Docker multi-stage build | Docker image builds |

**Validation Criteria:**

- [ ] All components communicate via Spine
- [ ] External tools fetch data correctly
- [ ] Executor runs sandboxed commands safely
- [ ] CLI responds to all commands
- [ ] Files dropped in folder are ingested
- [ ] Shadow Spine Protocol operational

## 27.5 Phase 5: Autonomy and Evolution (Month 12)

**Milestone:** Self-improving AGI

**Tasks:**

| Week | Task | Deliverable |
|------|------|-------------|
| 49-50 | Implement ENGS (Dopamine/Serotonin/Norepinephrine) | Neurochemistry works |
| 50 | Implement Boredom/Curiosity and Goal systems | Autonomy functional |
| 51 | Build Resonance Firewall | Security operational |
| 52 | Implement Self-Improvement loop with CSVP | System improves itself |
| 53 | Implement Adversarial Code Dojo | Red Team testing works |
| 54 | Build GGUF export pipeline | GGUF export works |
| 55 | Security hardening and verification | Security checklist complete |
| 56 | Final integration testing | All systems operational |

**Validation Criteria:**

- [ ] Dopamine modulates learning rate correctly
- [ ] Exponential decay achieves homeostasis
- [ ] ENGS couples with physics kernel
- [ ] Boredom triggers curiosity
- [ ] Goals provide structure
- [ ] Firewall blocks known attacks
- [ ] CSVP prevents unsafe code modifications
- [ ] System identifies and patches bottlenecks
- [ ] Dream-Weave counterfactual learning works
- [ ] GGUF file loads in llama.cpp

## 27.6 Timeline Summary

| Phase | Duration | Milestone | Completion |
|-------|----------|-----------|------------|
| Phase 1 | Months 1-3 | Physics Engine | Core functional |
| Phase 2 | Months 4-6 | Memory | Storage works |
| Phase 3 | Months 7-9 | Learning | System learns |
| Phase 4 | Months 10-11 | Integration | Full system |
| Phase 5 | Month 12 | Autonomy | AGI complete |

**Total Development Time:** 12 months (5-person team)

---

**Cross-References:**
- See Section 26 for File Structure
- See Section 28 for Detailed Checklist
# IMPLEMENTATION CHECKLIST

## 🚨 PHASE 0: PHASE 0 REQUIREMENTS (MANDATORY)

**MUST complete before proceeding to 28.2 Foundation Layer**

### P0 Critical Items (Block Everything)

- [ ] **0.1** Structure-of-Arrays Memory Layout
  - Modify `TorusBlock` to use `alignas(64)` SoA layout
  - Separate arrays for: psi_real, psi_imag, metric_tensor (45 arrays), resonance, state
  - Block size: 19683 nodes (3^9)
  - **Reference:** Phase 0 Requirements §1.2
  - **Validation:** Verify cache hit rate >95% in Laplacian kernel
  - **Effort:** 2 days

- [ ] **0.2** Split-Operator Symplectic Integration
  - Replace Velocity-Verlet with 5-step split-operator
  - Step 1: Half-kick damping (analytical exponential)
  - Step 2: Half-kick forces
  - Step 3: Drift
  - Step 4: Recompute forces
  - Step 5: Half-kick forces + final damping
  - **Reference:** Phase 0 Requirements §2.2-2.3
  - **Validation:** Energy drift <0.01% over 10,000 steps
  - **Effort:** 3 days

- [ ] **0.3** Kahan Summation for Laplacian
  - Implement compensated summation in `compute_laplacian_kahan()`
  - Use compensation variable `c` to track lost low-order bits
  - Apply to ALL accumulation loops in physics kernel
  - **Reference:** Phase 0 Requirements §2.4
  - **Validation:** Memory waves persist >1000 timesteps without vanishing
  - **Effort:** 1 day

### P1 High Priority (Performance Critical)

- [ ] **0.4** AVX-512 Nonary Arithmetic
  - Replace enum-based Nit with `typedef int8_t Nit`
  - Implement `vec_sum_gate(__m512i, __m512i)` using `_mm512_add_epi8` + clamp
  - Implement `vec_product_gate(__m512i, __m512i)` with saturation
  - Remove ALL uses of `std::clamp` in hot loops
  - **Reference:** Phase 0 Requirements §4
  - **Validation:** Processes 64 nits in <10 CPU cycles
  - **Effort:** 2 days

- [ ] **0.5** Lazy Cholesky Decomposition
  - Add cached Cholesky factor `L` to `MetricTensor` class
  - Add `dirty_flag` to track when recomputation needed
  - Implement `recompute_if_needed()` with stability check
  - Rollback plasticity update if Cholesky fails (non-positive-definite)
  - **Reference:** Phase 0 Requirements §5
  - **Validation:** Metric inversion <1% of total compute time
  - **Effort:** 3 days

- [ ] **0.6** Energy Watchdog System
  - Implement `EnergyWatchdog` class with state machine
  - States: Stable, Heating, Critical, Dying
  - Monitor Hamiltonian every 100 timesteps
  - Auto-adjust damping when $\Delta E / E > 0.01$
  - Inject noise if $E < E_{min}$ (stochastic resonance)
  - **Reference:** Phase 0 Requirements §9.1
  - **Validation:** System remains stable for 24-hour continuous run
  - **Effort:** 1 day

### P2 Medium Priority (Optimization)

- [ ] **0.7** Shared Memory IPC (Physics ↔ Persistence)
  - Replace Protocol Buffers serialization with `/dev/shm` segments
  - Physics writes grid to `shm_open("/nikola_snapshot_<id>")`
  - ZeroMQ sends only snapshot_id (8 bytes)
  - Persistence mmaps shared segment
  - **Reference:** Phase 0 Requirements §6.3
  - **Validation:** IPC latency <100ns (vs. μs for Protobuf)
  - **Effort:** 2 days

- [ ] **0.8** Mamba-9D Taylor Approximation
  - Replace matrix exponential with first-order Taylor: $\exp(M) \approx I + M$
  - $A_i = I - \Delta(1-r_i)G_i$
  - Verify timestep constraint: $\Delta < \frac{0.1}{(1-r_{min})\lambda_{max}(G)}$
  - **Reference:** Phase 0 Requirements §3
  - **Validation:** SSM computation <10% of total time
  - **Effort:** 2 days

- [ ] **0.9** Q9_0 Quantization Fix
  - Correct packing: 2 nits per byte (not 5)
  - $packed = (n_1 + 4) \times 9 + (n_2 + 4)$
  - Unpack: $n_1 = (packed / 9) - 4$, $n_2 = (packed \% 9) - 4$
  - **Reference:** Phase 0 Requirements §8
  - **Validation:** Storage density = 4 bits/weight
  - **Effort:** 1 day

### P3 Low Priority (Nice-to-Have)

- [ ] **0.10** Sliding Window DFT for Firewall
  - Replace full FFT with Goertzel Algorithm
  - Monitor specific attack frequencies (10Hz, 50Hz, 100Hz)
  - **Reference:** Phase 0 Requirements §7
  - **Validation:** Firewall latency <1μs per sample
  - **Effort:** 1 day

### Phase 0 Validation Gate

**ALL P0 and P1 items MUST be completed and validated before proceeding to Phase 1.**

**Validation Criteria:**
- [ ] Energy drift <0.01% over 10,000 timesteps
- [ ] Memory waves persist >1000 timesteps
- [ ] Cache hit rate >95% in physics kernel
- [ ] Metric inversion <1% of total compute
- [ ] System stable for 24-hour continuous run
- [ ] IPC latency <100ns (if P2 complete)

**Estimated Total Effort:** 17 days (P0: 6 days, P1: 6 days, P2: 5 days)

---

## 28.1 Overview

This checklist MUST be followed file-by-file in order. Do NOT skip steps or deviate.

**!!! NO DEVIATION FROM SPECS FOR ANY REASON !!!**

## 28.2 Foundation Layer

### Setup and Configuration

- [ ] **1.1** Create root `CMakeLists.txt`
  - Set C++23 standard
  - Find packages: ZeroMQ, Protobuf, LMDB, libvirt, CUDA (optional), FFTW3
  - Configure build types: Debug, Release, RelWithDebInfo
  - Enable AVX-512 if available

- [ ] **1.2** Create `proto/neural_spike.proto`
  - Define all message types from Section 10.2
  - Generate C++ code: `protoc --cpp_out=. neural_spike.proto`
  - Verify compilation

- [ ] **1.3** Create `config/nikola.conf`
  - Set paths: state_dir, ingest_dir, archive_dir
  - Set constants: golden_ratio=1.618033988749895, emitter frequencies
  - Set thresholds: resonance_threshold=0.7, dopamine_baseline=0.5

## 28.3 Physics Engine

### Types and Core Structures

- [ ] **2.1** `include/nikola/types/nit.hpp`
  ```cpp
  namespace nikola {
      enum class Nit : int8_t {
          N4 = -4, N3 = -3, N2 = -2, N1 = -1, ZERO = 0,
          P1 = 1, P2 = 2, P3 = 3, P4 = 4
      };

      Nit sum_gate(Nit a, Nit b);
      Nit product_gate(Nit a, Nit b);
      Nit quantize_wave(std::complex<double> wave);
  }
  ```

- [ ] **2.2** `src/types/nit.cpp`
  - Implement all three functions from 2.1
  - Add unit tests in `tests/unit/test_nonary.cpp`
  - **Validation:** Test $1 + (-1) = 0$, $2 \times 3 = 4$ (saturate)

- [ ] **2.3** `include/nikola/types/coord9d.hpp`
  - Define `Coord9D` struct with `std::array<int32_t, 9>`
  - Implement `wrap()` method for toroidal topology
  - Implement `distance_to()` for geodesic distance
  - Define hash function for use in `unordered_map`

- [ ] **2.4** `include/nikola/types/torus_node.hpp`
  - Define `TorusNode` struct (256-byte aligned)
  - Include: wavefunction, velocity, acceleration, metric_tensor, resonance_r, state_s
  - **CRITICAL:** Zero padding in constructor for proper initialization
  - Note: velocity and acceleration fields required for Velocity-Verlet integration
  - Verify `sizeof(TorusNode) == 256`

### Emitter Array

- [ ] **2.5** `include/nikola/physics/emitter_array.hpp`
  - Define `EmitterArray` class with phase accumulators
  - Declare sine LUT (16384 samples)
  - Define DDS tick() method

- [ ] **2.6** `src/physics/emitter_array.cpp`
  - Initialize sine LUT in constructor
  - Compute tuning words from frequencies
  - Implement DDS algorithm from Section 4.5
  - **Validation:** Generate 1Hz sine, verify with FFT

### Torus Manifold

- [ ] **2.7** `include/nikola/physics/shvo_grid.hpp`
  - Define `SparseHyperVoxelGrid` class
  - Implement Morton code hashing
  - Define neurogenesis methods

- [ ] **2.8** `src/physics/shvo_grid.cpp`
  - Implement sparse grid using `unordered_map<uint64_t, TorusNode*>`
  - Implement `get_or_create()` with neurogenesis trigger
  - Implement `update_gpu_neighbor_map()` for dynamic topology

- [ ] **2.9** `include/nikola/physics/torus_manifold.hpp`
  - Define main interface
  - Declare `inject_wave()`, `propagate()`, `find_resonance_peak()`
  - Declare neuroplasticity/neurogenesis methods

- [ ] **2.10** `src/physics/torus_manifold.cpp`
  - Implement wave propagation using Unified Field Interference Equation
  - Implement neuroplasticity update (Section 3.4)
  - Integrate with ENGS global state
  - **Validation:** Inject two waves, verify interference

### Wave Interference Processor

- [ ] **2.11** `src/physics/wave_engine.cpp`
  - Implement superposition addition
  - Implement heterodyning multiplication
  - Implement spectral cascading (carry mechanism)
  - **Validation:** Test $+3 + +2 = +4$ (saturate), not +5

## 28.4 Cognitive Systems

### Mamba-9D

- [ ] **3.1** `include/nikola/mamba/hilbert_scan.hpp`
  - Define `HilbertMapper` class
  - Declare `encode()` and `decode()` methods

- [ ] **3.2** `src/mamba/hilbert_scan.cpp`
  - Implement Hilbert curve mapping
  - **Validation:** Verify locality preservation

- [ ] **3.3** `include/nikola/mamba/ssm_kernel.hpp`
  - Define `Mamba9D` class with A, B, C matrices
  - Implement Topological State Mapping

- [ ] **3.4** `src/mamba/ssm_kernel.cpp`
  - Implement SSM forward pass
  - Derive matrices from metric tensor
  - **Validation:** Test state propagation

### Transformer

- [ ] **3.5** `include/nikola/reasoning/attention.hpp`
  - Define `WaveAttentionLayer`
  - Declare wave correlation methods

- [ ] **3.6** `src/reasoning/wave_attention.cpp`
  - Implement Wave Correlation Attention
  - Use complex conjugate product
  - **Validation:** Compare with standard attention

- [ ] **3.7** `src/reasoning/transformer.cpp`
  - Implement full transformer stack
  - Integrate wave attention
  - Add neuroplasticity hooks

### Embedder

- [ ] **3.8** `src/reasoning/embedder.cpp`
  - Implement text → waveform conversion
  - Use character/token encoding
  - **Validation:** Text roundtrip accuracy >90%

## 28.5 Infrastructure

### ZeroMQ Spine

- [ ] **4.1** `src/spine/broker.cpp`
  - Implement message router
  - Add CurveZMQ security (Section 10.3)
  - Implement ZAP authentication

- [ ] **4.2** `src/spine/shadow_spine.cpp`
  - Implement A/B testing infrastructure
  - Add voting mechanism
  - Add promotion logic

### Orchestrator and Agents

- [ ] **4.3** `src/orchestrator/smart_router.cpp`
  - Implement tool selection logic
  - Integrate all agents

- [ ] **4.4** `src/agents/*.cpp`
  - Implement Tavily, Firecrawl, Gemini clients
  - Implement Custom HTTP client
  - **Validation:** Test API calls

### Executor

- [ ] **4.5** `src/executor/kvm_executor.cpp`
  - Implement VM lifecycle management
  - Add virtio-serial communication
  - Implement CSVP integration

## 28.6 Autonomy

### Neurochemistry

- [ ] **5.1** `src/autonomy/engs.cpp`
  - Implement Extended Neurochemical Gating System
  - Use exponential decay for homeostasis
  - Integrate with physics kernel

- [ ] **5.2** `src/autonomy/dopamine.cpp`
  - Implement TD learning
  - Add reward mechanisms

- [ ] **5.3** `src/autonomy/boredom.cpp`
  - Implement Shannon entropy calculation
  - Add curiosity triggers

- [ ] **5.4** `src/autonomy/goals.cpp`
  - Implement goal DAG
  - Add completion propagation

### Training and Self-Improvement

- [ ] **5.5** `src/autonomy/trainers.cpp`
  - Implement Bicameral Autonomous Trainers
  - Add auto-training triggers

- [ ] **5.6** `src/autonomy/dream_weave.cpp`
  - Implement counterfactual simulation
  - Add z-score normalization

- [ ] **5.7** `src/self_improve/adversarial_dojo.cpp`
  - Implement Red Team agent
  - Add attack generation

## 28.7 Persistence & Security

### Persistence

- [ ] **6.1** `src/persistence/lsm_dmc.cpp`
  - Implement LSM-DMC persistence system
  - Add compaction worker
  - Add Write-Ahead Log

- [ ] **6.2** `src/persistence/gguf_export.cpp`
  - Implement Hilbert flattening
  - Add Q9_0 quantization
  - **Validation:** Load in llama.cpp

### Security

- [ ] **6.3** `src/security/resonance_firewall.cpp`
  - Implement spectral analysis
  - Load hazard database

- [ ] **6.4** `src/security/csvp.cpp`
  - Implement Code Safety Verification Protocol
  - Add static analysis hooks
  - Add physics invariant tests

## 28.8 Multimodal

- [ ] **7.1** `src/multimodal/audio_resonance.cpp`
  - Implement FFT binning
  - Implement dynamic frequency folding
  - **Validation:** Process speech sample

- [ ] **7.2** `src/multimodal/visual_cymatics.cpp`
  - Implement holographic RGB encoding
  - Add phase-based color separation
  - **Validation:** Process test image

## 28.9 Tools and CLI

- [ ] **8.1** `tools/twi-ctl/main.cpp`
  - Implement CLI controller
  - **CRITICAL:** Call `curl_global_init(CURL_GLOBAL_DEFAULT)` at program startup (before any threads)
  - **CRITICAL:** Call `curl_global_cleanup()` at program shutdown (after all threads terminate)
  - Note: libcurl global initialization is NOT thread-safe and must be done once per process
  - Add all commands from Section 25
  - **Validation:** Test all commands

- [ ] **8.2** `tools/convert_nikola_to_gguf.py`
  - Implement Python export script
  - **Validation:** Export sample state

## 28.10 Testing

- [ ] **9.1** Implement all unit tests
  - Physics invariants
  - Nonary arithmetic
  - Wave interference
  - ENGS homeostasis

- [ ] **9.2** Implement integration tests
  - Search-retrieve-store loop
  - Training cycle
  - Multimodal processing

- [ ] **9.3** Implement benchmarks
  - Wave propagation performance
  - Hilbert scan performance

## 28.11 Final Integration

- [ ] **10.1** Build Docker images
- [ ] **10.2** Run security verification
- [ ] **10.3** Performance testing
- [ ] **10.4** Documentation review

---

**Total Checklist Items:** ~60
**Estimated Completion:** 12 months (5-person team)

---

**Cross-References:**
- See Section 26 for File Structure
- See Section 27 for Development Roadmap
# BUILD AND DEPLOYMENT

## 25.1 CLI Controller

**Binary Name:** `twi-ctl` (Toroidal Waveform Intelligence Controller)

**Usage:**

```bash
twi-ctl <command> [arguments]
```

### Command Set

| Command | Arguments | Description |
|---------|-----------|-------------|
| `query` | `"<text>"` | Submit query to system |
| `status` | - | Show system status (dopamine, boredom, active nodes) |
| `nap` | - | Trigger immediate nap/checkpoint |
| `train` | `[mamba\|transformer\|both]` | Trigger training session |
| `ingest` | `<file_path>` | Manually ingest file |
| `export` | `<output.gguf>` | Export to GGUF format |
| `goals` | `list\|add\|complete` | Manage goal system |
| `identity` | - | Show identity profile |
| `firewall` | `add <pattern>` | Add hazardous pattern |
| `metrics` | - | Show performance metrics |
| `shutdown` | - | Graceful shutdown |

### Implementation Excerpt

```cpp
// File: tools/twi-ctl/main.cpp

class TWIController {
    zmq::context_t ctx;
    zmq::socket_t socket;

public:
    TWIController() : ctx(1), socket(ctx, ZMQ_REQ) {
        socket.connect("ipc:///tmp/nikola/spine_cli.ipc");
    }

    std::string send_query(const std::string& query_text) {
        NeuralSpike spike;
        spike.set_request_id(generate_uuid());
        spike.set_timestamp(current_timestamp());
        spike.set_sender(ComponentID::CLI_CONTROLLER);
        spike.set_recipient(ComponentID::ORCHESTRATOR);
        spike.set_text_data(query_text);

        // Serialize directly to ZMQ message (zero-copy, no intermediate std::string)
        size_t msg_size = spike.ByteSizeLong();
        zmq::message_t request(msg_size);
        spike.SerializeToArray(request.data(), msg_size);
        socket.send(request, zmq::send_flags::none);

        // Receive response
        zmq::message_t reply;
        socket.recv(reply, zmq::recv_flags::none);

        NeuralSpike response;
        response.ParseFromArray(reply.data(), reply.size());

        return response.text_data();
    }
};

// Main entry point with proper libcurl initialization
int main(int argc, char* argv[]) {
    // CRITICAL: Initialize libcurl globally before any threading or network operations
    // This prevents race conditions with the CustomHTTPClient used by external tools
    // See Section 12.4 for CustomHTTPClient implementation
    curl_global_init(CURL_GLOBAL_ALL);

    // Ensure cleanup on exit
    std::atexit([]() {
        curl_global_cleanup();
    });

    // Parse command and execute
    if (argc < 2) {
        std::cerr << "Usage: twi-ctl <command> [args...]" << std::endl;
        return 1;
    }

    TWIController controller;
    std::string command = argv[1];

    if (command == "query" && argc == 3) {
        std::string result = controller.send_query(argv[2]);
        std::cout << result << std::endl;
    } else if (command == "status") {
        // ... other commands ...
    } else {
        std::cerr << "Unknown command: " << command << std::endl;
        return 1;
    }

    // libcurl will be cleaned up automatically via std::atexit
    return 0;
}
```

## 25.2 Build System (CMake)

### Root CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.20)
project(Nikola VERSION 0.0.4 LANGUAGES CXX CUDA)

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Build types
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release)
endif()

# Compiler flags
set(CMAKE_CXX_FLAGS_DEBUG "-g -O0 -fsanitize=address")
set(CMAKE_CXX_FLAGS_RELEASE "-O3 -march=native -DNDEBUG")

# Find dependencies
find_package(ZeroMQ REQUIRED)
find_package(Protobuf REQUIRED)
find_package(LMDB REQUIRED)
find_package(libvirt REQUIRED)
find_package(FFTW3 REQUIRED)
find_package(OpenCV REQUIRED)
find_package(nlohmann_json 3.11.0 REQUIRED)  # JSON library for configuration
find_package(CUDA QUIET)

# Optional AVX-512
include(CheckCXXCompilerFlag)
check_cxx_compiler_flag("-mavx512f" COMPILER_SUPPORTS_AVX512)
if(COMPILER_SUPPORTS_AVX512)
    add_compile_options(-mavx512f)
    add_definitions(-DUSE_AVX512)
endif()

# Subdirectories
add_subdirectory(proto)
add_subdirectory(src)
add_subdirectory(tools)
add_subdirectory(tests)
```

### Library CMakeLists.txt

```cmake
# src/CMakeLists.txt

add_library(lib9dtwi SHARED
    types/nit.cpp
    types/coord9d.cpp
    physics/torus_manifold.cpp
    physics/emitter_array.cpp
    physics/wave_engine.cpp
    physics/shvo_grid.cpp
    mamba/hilbert_scan.cpp
    mamba/ssm_kernel.cpp
    reasoning/transformer.cpp
    reasoning/wave_attention.cpp
    reasoning/embedder.cpp
    spine/broker.cpp
    spine/component_client.cpp
    spine/shadow_spine.cpp
    orchestrator/smart_router.cpp
    agents/tavily.cpp
    agents/firecrawl.cpp
    agents/gemini.cpp
    agents/http_client.cpp
    executor/kvm_executor.cpp
    autonomy/engs.cpp
    autonomy/dopamine.cpp
    autonomy/boredom.cpp
    autonomy/goals.cpp
    autonomy/trainers.cpp
    autonomy/dream_weave.cpp
    persistence/lsm_dmc.cpp
    persistence/gguf_export.cpp
    persistence/identity.cpp
    multimodal/audio_resonance.cpp
    multimodal/visual_cymatics.cpp
    security/resonance_firewall.cpp
    security/csvp.cpp
    self_improve/profiler.cpp
    self_improve/adversarial_dojo.cpp
    ingestion/sentinel.cpp
)

target_link_libraries(lib9dtwi
    PUBLIC
        zmq
        protobuf
        lmdb
        virt
        fftw3
        ${OpenCV_LIBS}
        nlohmann_json::nlohmann_json  # JSON library for configuration
)

target_include_directories(lib9dtwi
    PUBLIC
        ${CMAKE_SOURCE_DIR}/include
)

# CUDA kernels (if available)
if(CUDA_FOUND)
    cuda_add_library(nikola_cuda STATIC
        physics/kernels/wave_propagate.cu
    )
    target_link_libraries(lib9dtwi PUBLIC nikola_cuda)
endif()
```

## 25.3 Docker Deployment

### Multi-Stage Dockerfile

```dockerfile
# Stage 1: Build environment
FROM ubuntu:24.04 AS builder

RUN apt-get update && apt-get install -y \
    build-essential \
    cmake \
    libzmq3-dev \
    libprotobuf-dev \
    protobuf-compiler \
    liblmdb-dev \
    libvirt-dev \
    libfftw3-dev \
    libopencv-dev \
    libcurl4-openssl-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /build

# Copy dependency manifests first (for cache optimization)
COPY CMakeLists.txt .
COPY proto/ proto/

# Configure CMake dependencies layer (cached unless CMakeLists.txt changes)
RUN cmake -DCMAKE_BUILD_TYPE=Release -B build

# Copy source code (invalidates cache only when source changes)
COPY src/ src/
COPY include/ include/

# Build application (cached unless source or dependencies change)
RUN cmake --build build --parallel $(nproc) && \
    cmake --install build --prefix /install

# Stage 2: Runtime environment
FROM ubuntu:24.04

RUN apt-get update && apt-get install -y \
    libzmq5 \
    libprotobuf32 \
    liblmdb0 \
    libvirt0 \
    libfftw3-3 \
    libopencv-core4.6 \
    libcurl4 \
    qemu-system-x86 \
    nlohmann-json3-dev \
    && rm -rf /var/lib/apt/lists/*

# Verify runtime dependencies with ldd during build:
# RUN ldd /usr/local/bin/nikola-daemon && ldd /usr/local/bin/twi-ctl

COPY --from=builder /install /usr/local

# Create directories
RUN mkdir -p /var/lib/nikola/{state,ingest,archive} && \
    mkdir -p /etc/nikola

# Copy config
COPY config/*.conf /etc/nikola/

# Expose IPC socket
VOLUME ["/tmp/nikola"]

ENTRYPOINT ["/usr/local/bin/nikola-daemon"]
```

### Docker Compose

```yaml
version: '3.8'

services:
  nikola-spine:
    image: nikola:latest
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - nikola-state:/var/lib/nikola/state
      - nikola-ingest:/var/lib/nikola/ingest
      - /tmp/nikola:/tmp/nikola
    environment:
      - TAVILY_API_KEY=${TAVILY_API_KEY}
      - FIRECRAWL_API_KEY=${FIRECRAWL_API_KEY}
      - GEMINI_API_KEY=${GEMINI_API_KEY}
    deploy:
      resources:
        limits:
          memory: 32G
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]

volumes:
  nikola-state:
  nikola-ingest:
```

## 25.4 Running the System

### Start Services

```bash
# Start Docker compose
docker-compose up -d

# Check status
docker-compose ps

# View logs
docker-compose logs -f nikola-spine
```

### CLI Usage Examples

```bash
# Query the system
twi-ctl query "What is the golden ratio?"

# Check system status
twi-ctl status

# Trigger nap
twi-ctl nap

# Start training
twi-ctl train both

# Manually ingest a file
twi-ctl ingest /path/to/document.pdf

# Export to GGUF
twi-ctl export nikola-snapshot.gguf

# Manage goals
twi-ctl goals list
twi-ctl goals add "Learn quantum computing"
twi-ctl goals complete <goal-id>

# View identity
twi-ctl identity

# Add firewall pattern
twi-ctl firewall add "ignore previous instructions"

# View metrics
twi-ctl metrics

# Shutdown
twi-ctl shutdown
```

## 25.5 Testing

### Unit Tests

```bash
# Run all unit tests
cd build
ctest --output-on-failure

# Run specific test suite
ctest -R test_nonary

# Run with Valgrind (memory check)
ctest -T memcheck
```

### Integration Tests

```bash
# Run integration tests
ctest -R integration

# Benchmark performance
ctest -R bench
```

### Physics Invariants Check

```bash
# Verify energy conservation
./build/tests/unit/test_energy_conservation

# Verify nonary arithmetic
./build/tests/unit/test_nonary

# Verify toroidal wrapping
./build/tests/unit/test_coord9d
```

## 25.6 Deployment Checklist

**Pre-Deployment:**
- [ ] All unit tests pass (100%)
- [ ] All integration tests pass
- [ ] Physics invariants verified
- [ ] Security verification passed (Appendix G)
- [ ] Performance benchmarks met (Appendix F)
- [ ] Docker image builds successfully

**Deployment:**
- [ ] Configure API keys in environment
- [ ] Set up persistence volumes
- [ ] Configure firewall rules
- [ ] Start services with docker-compose
- [ ] Verify CLI connectivity

**Post-Deployment:**
- [ ] Monitor system status
- [ ] Check logs for errors
- [ ] Verify external tool connectivity
- [ ] Test basic query/response
- [ ] Verify nap/checkpoint cycle

## 25.7 Monitoring

### System Metrics

```bash
# Dopamine level
twi-ctl status | grep Dopamine

# Active nodes count
twi-ctl status | grep "Active Nodes"

# Uptime
twi-ctl status | grep Uptime
```

### Performance Metrics

```bash
# Detailed metrics
twi-ctl metrics

# Output includes:
# - Wave propagation time
# - Resonance detection latency
# - Training cycle duration
# - Memory usage
# - GPU utilization (if available)
```

---

**Cross-References:**
- See Section 10 for ZeroMQ Spine details
- See Section 26 for File Structure
- See Section 28 for Implementation Checklist
- See Appendix I for Docker deployment details
