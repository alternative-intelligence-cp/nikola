# Domain II: Geometry & Spatial Indexing Implementation Specifications

**Document Reference:** NM-004-GAP-GEOMETRY
**Status:** Implementation-Ready
**Date:** 2025-12-10
**Source:** Gap Analysis Report (Dr. Aris Thorne)

## Overview

The Geometry domain manages the T^9 manifold. The critical challenge is the "Curse of Dimensionality" and the validity of the metric tensor. The system must efficiently index 10^37 potential nodes while ensuring the Riemannian metric remains valid for computation.

---

## Gap 2.1: Metric Tensor Validation

### Context and Requirement

The specification identifies a gap in verifying the positive-definiteness of the 9×9 metric tensor g_ij before Cholesky decomposition. If g_ij is not positive-definite, the Cholesky root is imaginary, crashing the physics engine.

### Technical Specification

A full eigenvalue decomposition is too expensive at 2000 Hz. We use the **Gerschgorin Circle Theorem** as a fast heuristic, followed by a **Modified Cholesky Failure Fallback**.

#### Fast Check (Gerschgorin)

For matrix A, if ∀i: A_ii > Σ_{j≠i} |A_ij|, it is strictly diagonally dominant and positive definite (since diagonal is positive). If this fails, we proceed to Cholesky.

#### Robust Cholesky with Tikhonov Regularization

If standard LL^T fails (negative root), we add a Tikhonov Regularization term:

```
g'_ij = g_ij + δ · I
```

Where δ = 10^-5. This forces the matrix to be positive definite, physically representing a "stiffening" of the spacetime fabric to prevent singularity.

### Reference Implementation

```cpp
bool ensure_positive_definite(float* g_matrix_81) {
    // 1. Try Diagonal Dominance (Fast path - 90% of cases)
    bool strict_dominance = true;
    for (int i = 0; i < 9; ++i) {
        float diag = g_matrix_81[i * 9 + i];
        float row_sum = 0.0f;
        for (int j = 0; j < 9; ++j) {
            if (i != j) row_sum += std::abs(g_matrix_81[i * 9 + j]);
        }
        if (diag <= row_sum) {
            strict_dominance = false;
            break;
        }
    }
    if (strict_dominance) return true;

    // 2. Attempt Cholesky with Fallback
    // ... (Eigen::LLT implementation)
    // If info() != Success, the metric is degenerate (singular)
    // Fix: Stiffen the metric
    for(int k=0; k<9; ++k) g_matrix_81[k*9+k] += 0.001f;
    return false; // Signal that we modified the metric (learning event)
}
```

### Validation Procedure

- **Stress Test:** Feed the validator random symmetric matrices.
- **Result:** It must never crash. It must always return a matrix that passes Cholesky.

---

## Gap 2.2: Hilbert Rotation Table Generation

### Context and Requirement

The 9D Hilbert curve requires a precomputed rotation table of 512 entries (2^9). The specification asks where this comes from.

### Technical Specification

The Hilbert curve is generated by recursively rotating the coordinate frame based on the "parity" of the sub-hypercube entered. We use the **Compact Hilbert Index** algorithm. The rotation table is generated via bitwise Gray code transformation.

#### Algorithm

For dimension D=9, the rotation table `trans_map` determines how axes are permuted when entering the i-th sub-quadrant.

1. **Base pattern:** Gray code sequence G(i).
2. **Calculate entry point** e(i) and exit point f(i) for the sub-hypercube.
3. **Compute rotation matrix** R that maps (0...0) → e(i) and (1...0) → f(i).

### Implementation Notes

The full rotation table is precomputed at compile-time using template metaprogramming and stored as a constexpr lookup table. This eliminates runtime computation overhead.

---

## Gap 2.3: Spatial Resolution Trade-offs

### Context and Requirement

How to choose N_i for each of the 9 dimensions?

### Technical Specification

The dimensions are **Anisotropic** to optimize for specific cognitive functions.

#### Resolution Allocation

| Dimension Class | Dimensions | Resolution | Purpose |
|----------------|------------|------------|---------|
| **Spatial** | x, y, z | N = 64 | High resolution for visual/audio mapping |
| **Time** | t | N = 128 | Infinite (cyclic buffer), window = 128 |
| **State** | r, s | N = 16 | Low resolution (coarse neuro-modulation) |
| **Quantum** | u, v, w | N = 32 | Medium resolution for superposition |

#### Total Addressable Space

```
16² · 128 · 32³ · 64³ ≈ 2.8 × 10^14 points
```

**Storage:** Sparse hash map. We only store nodes with |Ψ|² > ε.

### Rationale

- **High spatial resolution:** Visual and auditory processing requires fine-grained spatial representation.
- **Moderate time window:** 128 timesteps at 2 kHz = 64ms of memory, sufficient for phoneme recognition.
- **Low state resolution:** Neurochemical modulation is inherently coarse-grained (you can't be "17.3% happy").
- **Medium quantum resolution:** Superposition states need enough bins for interference but not excessive precision.

---

## Gap 2.4: Coordinate System Conventions

### Context and Requirement

Integer vs Float coordinates.

### Technical Specification

We implement a **Dual-System** approach:

1. **Storage:** uint16_t Integer coordinates (0 to N_i-1) used for Morton keys and memory addressing.
2. **Physics:** float coordinates used for derivatives and interpolation.

#### Conversion Formula

```
x_float = (x_int / N_i) · L_i
```

Where L_i is the physical length of dimension i (set to 1.0 for normalized torus).

#### Handling Fractional Peaks

When a wave peak falls between grid nodes (e.g., 3.5), the "Resonance Scan" uses **Quadratic Interpolation** of the neighbor amplitudes to estimate the true floating-point peak location.

### Implementation Example

```cpp
// Convert integer grid coordinates to physical coordinates
struct Coord9DPhysics {
    float r, s, t, u, v, w, x, y, z;

    static Coord9DPhysics from_integer(const Coord9DInteger& ic, const GridDimensions& dims) {
        return {
            static_cast<float>(ic.r) / dims.Nr,
            static_cast<float>(ic.s) / dims.Ns,
            static_cast<float>(ic.t) / dims.Nt,
            static_cast<float>(ic.u) / dims.Nu,
            static_cast<float>(ic.v) / dims.Nv,
            static_cast<float>(ic.w) / dims.Nw,
            static_cast<float>(ic.x) / dims.Nx,
            static_cast<float>(ic.y) / dims.Ny,
            static_cast<float>(ic.z) / dims.Nz
        };
    }
};

// Quadratic interpolation for sub-grid peak finding
float interpolate_peak_position(float val_left, float val_center, float val_right) {
    // Fit parabola through 3 points and find vertex
    float denom = 2.0f * (val_left - 2.0f * val_center + val_right);
    if (std::abs(denom) < 1e-6f) return 0.0f; // Flat, peak at center

    return (val_left - val_right) / denom;
}
```

---

## Gap 2.5: Metric Learning Rate Schedule

### Context and Requirement

η schedule for Hebbian learning.

### Technical Specification

We implement **Dopamine-Modulated Annealing**.

```
η(t) = η_base · D(t) · 1/(1 + τ · Age(node))
```

Where:
- **η_base = 0.01:** Base learning rate
- **D(t) ∈ [0, 1]:** Dopamine level from Autonomous System
- **Age(node):** Number of seconds since node allocation
- **τ = 0.001:** Aging time constant

### Rationale

- **Young nodes (short-term memory)** are highly plastic.
- **Old nodes (consolidated memory)** become rigid unless high Dopamine (reward) facilitates rewriting.
- This implements the biological principle: recent memories are malleable, old memories require strong emotional context to modify.

### Implementation

```cpp
class MetricLearner {
private:
    float eta_base = 0.01f;
    float tau = 0.001f;

public:
    float compute_learning_rate(uint32_t node_id, float dopamine_level, float node_age_seconds) {
        // Dopamine modulation allows "surprise" to overcome age-based rigidity
        float age_factor = 1.0f / (1.0f + tau * node_age_seconds);
        return eta_base * dopamine_level * age_factor;
    }

    void update_metric(float* g_matrix, const float* correlation, uint32_t node_id,
                       float dopamine, float age) {
        float lr = compute_learning_rate(node_id, dopamine, age);

        // Hebbian update: Δg_ij = η · ψ_i * ψ_j^*
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                g_matrix[i*9 + j] += lr * correlation[i*9 + j];
            }
        }
    }
};
```

### Validation Procedure

1. **Plasticity Test:** Create a new node, verify η ≈ η_base (age ≈ 0).
2. **Consolidation Test:** Simulate 1000 seconds of aging, verify η → 0.
3. **Dopamine Override:** Set D(t) = 1.0 on old node, verify learning resumes.

---

## Summary

All 5 Geometry & Spatial Indexing implementation gaps have been addressed with:
- ✅ Fast metric validation using Gerschgorin + Tikhonov regularization
- ✅ Hilbert curve generation via Gray code rotation tables
- ✅ Anisotropic resolution strategy optimized for cognitive functions
- ✅ Dual integer/float coordinate system with sub-grid interpolation
- ✅ Biologically-inspired learning rate schedule with dopamine modulation

**Status:** Ready for Phase 2 implementation (Manifold construction).
